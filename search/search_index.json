{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyRE - Python Reinsurance","text":""},{"location":"#overview","title":"Overview","text":"<p><code>pyre</code> is a comprehensive Python package designed to provide pricing tools and utilities for non-life reinsurance professionals. It offers a wide range of actuarial and statistical methods for analyzing claims data, managing exposures, and pricing reinsurance contracts.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Claims Analysis: Tools for managing and analyzing claims data, including development triangles and IBNER pattern extraction</li> <li>Exposure Management: Classes for handling exposure data with various bases (earned, written)</li> <li>Treaty Modeling: Functionality for modeling reinsurance contracts and layers</li> <li>Experience Rating: Methods for burn cost analysis, frequency-severity modeling, and curve fitting</li> <li>Rate Monitoring: Tools for tracking rate adequacy and rate changes</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>To install the package, clone the repository and install the dependencies:</p> <pre><code>git clone https://github.com/rdj09/pyre.git\ncd pyre\npip install -e .\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Here's a simple example of how to use the package to analyze claims data:</p> <pre><code># Import the claims module\nfrom pyre.claims.claims import Claim, Claims, ClaimsMetaData, ClaimDevelopmentHistory\nfrom pyre.claims.triangles import Triangle\nfrom datetime import date\n\n# Create a claim with metadata and development history\nmetadata = ClaimsMetaData(\n    claim_id=\"CL001\",\n    currency=\"USD\",\n    loss_date=date(2022, 1, 15),\n    report_date=date(2022, 2, 1),\n    line_of_business=\"Property\"\n)\n\ndevelopment = ClaimDevelopmentHistory(\n    development_months=[0, 3, 6, 9, 12],\n    cumulative_dev_paid=[0, 10000, 25000, 40000, 50000],\n    cumulative_dev_incurred=[100000, 90000, 75000, 60000, 50000]\n)\n\nclaim = Claim(metadata, development)\n\n# Create a collection of claims\nclaims_collection = Claims([claim])\n\n# Create a triangle from claims data\ntriangle = Triangle.from_claims(claims_collection, value_type=\"incurred\")\n\n# Calculate age-to-age factors\nfactors = triangle.calculate_age_to_age_factors()\nprint(factors)\n</code></pre>"},{"location":"#directory-structure","title":"Directory Structure","text":"<pre><code>pyre/\n\u251c\u2500\u2500 docs/               # Documentation\n\u251c\u2500\u2500 src/                # Source code\n\u2502   \u2514\u2500\u2500 pyre/\n\u2502       \u251c\u2500\u2500 claims/     # Claims analysis tools\n\u2502       \u251c\u2500\u2500 exposures/  # Exposure management\n\u2502       \u251c\u2500\u2500 Models/     # Pricing models\n\u2502       \u251c\u2500\u2500 treaty/     # Reinsurance contract modeling\n\u2502       \u2514\u2500\u2500 rate_monitoring/ # Rate monitoring tools\n\u2514\u2500\u2500 tests/              # Test suite\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please follow these steps: 1. Fork the repository. 2. Create a new branch for your feature or bug fix. 3. Submit a pull request with a detailed description of your changes.</p>"},{"location":"#license","title":"License","text":"<p><code>pyre</code> is distributed under the terms of the MIT license.</p>"},{"location":"about/","title":"About pyRE","text":""},{"location":"about/#project-overview","title":"Project Overview","text":"<p>pyRE (Python Reinsurance) is a comprehensive Python package designed to provide actuarial and statistical tools for non-life reinsurance pricing and analysis. The package aims to standardize and streamline common reinsurance pricing workflows, making them more accessible, reproducible, and efficient.</p>"},{"location":"about/#key-features","title":"Key Features","text":"<p>pyRE offers a wide range of features organized into several modules:</p> <ul> <li>Claims Analysis: Tools for managing and analyzing claims data</li> <li>Exposure Management: Classes for handling exposure data</li> <li>Treaty Modeling: Functionality for modeling reinsurance contracts</li> <li>Experience Rating: Methods for analyzing historical experience</li> <li>Exposure Rating: Tools for exposure-based rating</li> <li>Rate Monitoring: Utilities for tracking rate changes and adequacy</li> </ul>"},{"location":"about/#getting-involved","title":"Getting Involved","text":"<p>There are several ways to get involved with the pyRE project:</p> <ul> <li>Use the package: Try pyRE for your reinsurance pricing needs</li> <li>Provide feedback: Report bugs, suggest features, or share your experience</li> <li>Contribute code: Submit pull requests to add features or fix issues</li> <li>Improve documentation: Help improve the documentation and examples</li> <li>Share knowledge: Discuss actuarial methods and their implementation</li> </ul> <p>Contact Information</p> <p>For questions, suggestions, or contributions, please contact the project maintainer: Rhys Jones rhysjones437@googlemail.com</p>"},{"location":"about/#license","title":"License","text":"<p>pyRE is distributed under the MIT License, which allows for free use, modification, and distribution, with limited restrictions. See the LICENSE.txt file for the full license text.</p>"},{"location":"claims/","title":"Claims Module","text":"<p>The Claims module provides tools for managing and analyzing claims data in reinsurance contexts. It includes classes for representing individual claims, collections of claims, and claims development triangles.</p>"},{"location":"claims/#core-classes","title":"Core Classes","text":""},{"location":"claims/#claims-data-structure","title":"Claims Data Structure","text":"<p>The module provides a hierarchical structure for representing claims:</p> <ul> <li><code>ClaimYearType</code>: An enumeration defining different claim year bases (Accident Year, Underwriting Year, etc.)</li> <li><code>ClaimDevelopmentHistory</code>: Tracks the development of a claim over time, including paid and incurred amounts</li> <li><code>ClaimsMetaData</code>: Contains metadata about a claim (ID, dates, limits, etc.)</li> <li><code>Claim</code>: Combines metadata and development history for a single claim</li> <li><code>Claims</code>: A collection of Claim objects with methods to access and manipulate them</li> </ul>"},{"location":"claims/#claims-triangles","title":"Claims Triangles","text":"<p>The triangles module provides tools for creating and analyzing claims development triangles:</p> <ul> <li><code>Triangle</code>: Represents a claims development triangle with methods for:</li> <li>Converting between cumulative and incremental triangles</li> <li>Calculating age-to-age factors</li> <li>Fitting curves to development patterns</li> <li><code>IBNERPatternExtractor</code>: Extracts IBNER (Incurred But Not Enough Reported) patterns from triangles</li> </ul>"},{"location":"claims/#examples","title":"Examples","text":""},{"location":"claims/#creating-and-working-with-claims","title":"Creating and Working with Claims","text":"<pre><code>from pyre.claims.claims import Claim, Claims, ClaimsMetaData, ClaimDevelopmentHistory, ClaimYearType\nfrom datetime import date\n\n# Create claim metadata\nmetadata = ClaimsMetaData(\n    claim_id=\"CL001\",\n    currency=\"USD\",\n    contract_limit=1000000,\n    contract_deductible=10000,\n    claim_year_basis=ClaimYearType.ACCIDENT_YEAR,\n    loss_date=date(2022, 3, 15),\n    report_date=date(2022, 4, 1),\n    line_of_business=\"Property\"\n)\n\n# Create claim development history\ndevelopment = ClaimDevelopmentHistory(\n    development_months=[0, 3, 6, 9, 12],\n    cumulative_dev_paid=[0, 15000, 30000, 45000, 50000],\n    cumulative_dev_incurred=[80000, 70000, 60000, 55000, 50000]\n)\n\n# Create a claim\nclaim = Claim(metadata, development)\n\n# Access claim properties\nprint(f\"Claim ID: {claim.claims_meta_data.claim_id}\")\nprint(f\"Latest paid amount: {claim.uncapped_claim_development_history.latest_paid()}\")\nprint(f\"Latest incurred amount: {claim.uncapped_claim_development_history.latest_incurred()}\")\nprint(f\"Latest reserved amount: {claim.uncapped_claim_development_history.latest_reserved_amount()}\")\n\n# Create a collection of claims\nclaims_collection = Claims([claim])\n\n# Add another claim\nsecond_claim = Claim(\n    ClaimsMetaData(\"CL002\", \"EUR\", loss_date=date(2022, 5, 10)),\n    ClaimDevelopmentHistory(\n        [0, 3, 6],\n        [0, 5000, 10000],\n        [20000, 15000, 12000]\n    )\n)\nclaims_collection.append(second_claim)\n\n# Access claims in the collection\nfor claim in claims_collection:\n    print(f\"Claim {claim.claims_meta_data.claim_id} - \"\n          f\"Loss date: {claim.claims_meta_data.loss_date}\")\n\n# Get unique modelling years\nprint(f\"Modelling years: {claims_collection.modelling_years()}\")\n</code></pre>"},{"location":"claims/#working-with-claims-triangles","title":"Working with Claims Triangles","text":"<pre><code>from pyre.claims.triangles import Triangle, CurveType\nfrom pyre.claims.claims import Claims\n\n# Assuming we have a Claims collection called 'claims_data'\n\n# Create a triangle from claims data\nincurred_triangle = Triangle.from_claims(claims_data, value_type=\"incurred\")\npaid_triangle = Triangle.from_claims(claims_data, value_type=\"paid\")\n\n# Display the triangle\nprint(incurred_triangle)\n\n# Convert to incremental triangle\nincremental_triangle = incurred_triangle.to_incremental()\n\n# Calculate age-to-age factors\nfactors = incurred_triangle.calculate_age_to_age_factors()\nprint(\"Age-to-age factors:\")\nfor origin_year, factors_dict in factors.items():\n    print(f\"  Year {origin_year}: {factors_dict}\")\n\n# Get average age-to-age factors\navg_factors = incurred_triangle.get_average_age_to_age_factors(method=\"volume\")\nprint(f\"Volume-weighted average factors: {avg_factors}\")\n\n# Fit a curve to the development pattern\ncurve_params = incurred_triangle.fit_curve(CurveType.EXPONENTIAL)\nprint(f\"Curve parameters: {curve_params}\")\n\n# Extract IBNER pattern\nibner_extractor = IBNERPatternExtractor(incurred_triangle)\nibner_pattern = ibner_extractor.get_IBNER_pattern()\nprint(f\"IBNER pattern: {ibner_pattern}\")\n</code></pre>"},{"location":"claims/#api-reference","title":"API Reference","text":""},{"location":"claims/#pyre.claims.claims.Claim","title":"<code>Claim</code>","text":"<p>Represents an insurance claim with associated metadata and development history.</p> <p>This class provides access to the claim's metadata, uncapped and capped development histories, and a string representation for easy inspection. The uncapped and capped development histories are calculated based on the contract deductible and limit specified in the claim's metadata.</p> <p>Attributes:</p> Name Type Description <code>_claims_meta_data</code> <code>ClaimsMetaData</code> <p>Metadata associated with the claim, such as claim ID, deductible, and limit.</p> <code>_claim_development_history</code> <code>ClaimDevelopmentHistory</code> <p>The development history of the claim, including paid and incurred amounts over time.</p> <code>_uncapped_claim_development_history</code> <code>ClaimDevelopmentHistory</code> <p>Cached uncapped development history.</p> <code>_capped_claim_development_history</code> <code>ClaimDevelopmentHistory</code> <p>Cached capped development history.</p> Properties <p>claims_meta_data: Returns the claim's metadata. uncapped_claim_development_history: Returns the claim's development history after applying the deductible, but before applying the contract limit. capped_claim_development_history: Returns the claim's development history after applying both the deductible and the contract limit.</p> <p>Parameters:</p> Name Type Description Default <code>claims_meta_data</code> <code>ClaimsMetaData</code> <p>Metadata for the claim.</p> required <code>claims_development_history</code> <code>ClaimDevelopmentHistory</code> <p>Development history for the claim.</p> required Example <p>claim = Claim(meta_data, dev_history) print(claim.capped_claim_development_history)</p> Source code in <code>src\\pyre\\claims\\claims.py</code> <pre><code>class Claim:\n    \"\"\"Represents an insurance claim with associated metadata and development history.\n\n    This class provides access to the claim's metadata, uncapped and capped development histories,\n    and a string representation for easy inspection. The uncapped and capped development histories\n    are calculated based on the contract deductible and limit specified in the claim's metadata.\n\n    Attributes:\n        _claims_meta_data (ClaimsMetaData): Metadata associated with the claim, such as claim ID, deductible, and limit.\n        _claim_development_history (ClaimDevelopmentHistory): The development history of the claim, including paid and incurred amounts over time.\n        _uncapped_claim_development_history (ClaimDevelopmentHistory): Cached uncapped development history.\n        _capped_claim_development_history (ClaimDevelopmentHistory): Cached capped development history.\n\n    Properties:\n        claims_meta_data: Returns the claim's metadata.\n        uncapped_claim_development_history: Returns the claim's development history after applying the deductible, but before applying the contract limit.\n        capped_claim_development_history: Returns the claim's development history after applying both the deductible and the contract limit.\n\n    Args:\n        claims_meta_data (ClaimsMetaData): Metadata for the claim.\n        claims_development_history (ClaimDevelopmentHistory): Development history for the claim.\n\n    Example:\n        &gt;&gt;&gt; claim = Claim(meta_data, dev_history)\n        &gt;&gt;&gt; print(claim.capped_claim_development_history)\n    \"\"\"\n    def __init__(self, claims_meta_data: ClaimsMetaData, claims_development_history: ClaimDevelopmentHistory) -&gt; None:\n        self._claims_meta_data = claims_meta_data\n        self._claim_development_history = claims_development_history\n        self._uncapped_claim_development_history = None\n        self._capped_claim_development_history = None\n\n    @property\n    def claims_meta_data(self):\n        return self._claims_meta_data\n\n    @property\n    def uncapped_claim_development_history(self) -&gt; ClaimDevelopmentHistory:\n        if self._uncapped_claim_development_history is None:\n            if self._claims_meta_data.claim_in_xs_of_deductible:\n                uncapped_paid = self._claim_development_history.cumulative_dev_paid\n                uncapped_incurred = self._claim_development_history.cumulative_dev_incurred\n            else:\n                uncapped_paid = [max(paid - self._claims_meta_data.contract_deductible, 0.0) for paid in self._claim_development_history.cumulative_dev_paid]\n                uncapped_incurred = [max(incurred - self._claims_meta_data.contract_deductible, 0.0) for incurred in self._claim_development_history.cumulative_dev_incurred]\n            self._uncapped_claim_development_history = ClaimDevelopmentHistory(self._claim_development_history.development_months, uncapped_paid, uncapped_incurred)\n        return self._uncapped_claim_development_history\n\n    @property\n    def capped_claim_development_history(self) -&gt; ClaimDevelopmentHistory:\n        if self._capped_claim_development_history is None:\n            capped_paid = [min(paid, self._claims_meta_data.contract_limit) for paid in self.uncapped_claim_development_history.cumulative_dev_paid]\n            capped_incurred = [min(incurred, self._claims_meta_data.contract_limit) for incurred in self.uncapped_claim_development_history.cumulative_dev_incurred]\n            self._capped_claim_development_history = ClaimDevelopmentHistory(self._claim_development_history.development_months, capped_paid, capped_incurred)\n        return self._capped_claim_development_history\n\n\n    def __repr__(self) -&gt; str:\n        return (\n            f\"claim_id={self._claims_meta_data.claim_id},modelling_year={self._claims_meta_data.modelling_year},latest_incurred={self._claim_development_history.latest_incurred},latest_capped_incurred={self.capped_claim_development_history.latest_incurred}\"\n        )\n</code></pre>"},{"location":"claims/#pyre.claims.claims.ClaimDevelopmentHistory","title":"<code>ClaimDevelopmentHistory</code>","text":"<p>Represents the development history of an insurance claim, tracking cumulative and incremental paid and incurred amounts over development months.</p> <p>Attributes:</p> Name Type Description <code>development_months</code> <code>List[int]</code> <p>List of development months corresponding to each data point.</p> <code>cumulative_dev_paid</code> <code>List[float]</code> <p>Cumulative paid amounts at each development month.</p> <code>cumulative_dev_incurred</code> <code>List[float]</code> <p>Cumulative incurred amounts at each development month.</p> Properties <p>cumulative_reserved_amount (List[float]): List of reserved amounts (incurred minus paid) at each development month. latest_paid (float): Most recent cumulative paid amount, or 0.0 if no data. latest_incurred (float): Most recent cumulative incurred amount, or 0.0 if no data. latest_reserved_amount (float): Most recent reserved amount (incurred minus paid), or 0.0 if no data. latest_development_month (int): Most recent development month, or 0 if no data. incremental_dev_incurred (List[float]): List of incremental incurred amounts at each development month. incremental_dev_paid (List[float]): List of incremental paid amounts at each development month. mean_payment_duration (Optional[float]): Weighted average development month of payments, or None if no payments.</p> <p>Methods:</p> Name Description <code>incremental_dev</code> <p>Sequence[float]) -&gt; List[float]: Converts a sequence of cumulative values into incremental values.</p> Source code in <code>src\\pyre\\claims\\claims.py</code> <pre><code>class ClaimDevelopmentHistory:\n    \"\"\"Represents the development history of an insurance claim, tracking cumulative and incremental paid and incurred amounts over development months.\n\n    Attributes:\n        development_months (List[int]): List of development months corresponding to each data point.\n        cumulative_dev_paid (List[float]): Cumulative paid amounts at each development month.\n        cumulative_dev_incurred (List[float]): Cumulative incurred amounts at each development month.\n\n    Properties:\n        cumulative_reserved_amount (List[float]): List of reserved amounts (incurred minus paid) at each development month.\n        latest_paid (float): Most recent cumulative paid amount, or 0.0 if no data.\n        latest_incurred (float): Most recent cumulative incurred amount, or 0.0 if no data.\n        latest_reserved_amount (float): Most recent reserved amount (incurred minus paid), or 0.0 if no data.\n        latest_development_month (int): Most recent development month, or 0 if no data.\n        incremental_dev_incurred (List[float]): List of incremental incurred amounts at each development month.\n        incremental_dev_paid (List[float]): List of incremental paid amounts at each development month.\n        mean_payment_duration (Optional[float]): Weighted average development month of payments, or None if no payments.\n\n    Methods:\n        incremental_dev(cumulative_dev: Sequence[float]) -&gt; List[float]:\n            Converts a sequence of cumulative values into incremental values.\n    \"\"\"\n    def __init__(self, development_months=None, cumulative_dev_paid=None, cumulative_dev_incurred=None):\n        self._development_months = development_months if development_months is not None else []\n        self._cumulative_dev_paid = cumulative_dev_paid if cumulative_dev_paid is not None else []\n        self._cumulative_dev_incurred = cumulative_dev_incurred if cumulative_dev_incurred is not None else []\n\n        # Validate that all lists have the same length\n        self._validate_list_lengths()\n\n    def _validate_list_lengths(self) -&gt; None:\n        \"\"\"Validates that all development lists have the same length.\"\"\"\n        if len(self._development_months) != len(self._cumulative_dev_paid) or len(self._development_months) != len(self._cumulative_dev_incurred):\n            raise ValueError(\"All development lists (months, paid, incurred) must have the same length.\")\n\n    @property\n    def development_months(self) -&gt; List[int]:\n        return self._development_months\n\n    @development_months.setter\n    def development_months(self, value: List[int]) -&gt; None:\n        self._development_months = value\n        self._validate_list_lengths()\n\n    @property\n    def cumulative_dev_paid(self) -&gt; List[float]:\n        return self._cumulative_dev_paid\n\n    @cumulative_dev_paid.setter\n    def cumulative_dev_paid(self, value: List[float]) -&gt; None:\n        self._cumulative_dev_paid = value\n        self._validate_list_lengths()\n\n    @property\n    def cumulative_dev_incurred(self) -&gt; List[float]:\n        return self._cumulative_dev_incurred\n\n    @cumulative_dev_incurred.setter\n    def cumulative_dev_incurred(self, value: List[float]) -&gt; None:\n        self._cumulative_dev_incurred = value\n        self._validate_list_lengths()\n\n    @property\n    def cumulative_reserved_amount(self) -&gt; List[float]:\n        \"\"\"Returns a list of reserved amounts (incurred minus paid) at each development month.\"\"\"\n        return [incurred - paid for incurred, paid in zip(self.cumulative_dev_incurred, self.cumulative_dev_paid)]\n\n    @property\n    def latest_paid(self) -&gt; float:\n        return self.cumulative_dev_paid[-1] if self.cumulative_dev_paid else 0.0\n\n    @property\n    def latest_incurred(self) -&gt; float:\n        return self.cumulative_dev_incurred[-1] if self.cumulative_dev_incurred else 0.0\n\n    @property\n    def latest_reserved_amount(self) -&gt; float:\n        return self.cumulative_dev_incurred[-1] - self.cumulative_dev_paid[-1] if self.cumulative_dev_paid else 0.0\n\n    @property\n    def latest_development_month(self) -&gt; int:\n        return self.development_months[-1] if self.development_months else 0\n\n    @staticmethod\n    def incremental_dev(cumulative_dev: Sequence[float]) -&gt; List[float]:\n        incremental_dev = [cumulative_dev[0]]\n        incremental_dev.extend([cumulative_dev[i] - cumulative_dev[i - 1] for i in range(1, len(cumulative_dev))])\n        return incremental_dev\n    @property\n    def incremental_dev_incurred(self) -&gt; List[float]:\n        return self.incremental_dev(self.cumulative_dev_incurred)\n\n    @property\n    def incremental_dev_paid(self) -&gt; List[float]:\n        return self.incremental_dev(self.cumulative_dev_paid)\n\n    @property\n    def mean_payment_duration(self) -&gt; Optional[float]:\n        if self.latest_paid &gt; 0:\n            time_weighted_payments = sum(month * paid for month, paid in zip(self.development_months, self.incremental_dev_paid))\n            return time_weighted_payments / self.latest_paid\n        return None\n</code></pre>"},{"location":"claims/#pyre.claims.claims.ClaimDevelopmentHistory.cumulative_reserved_amount","title":"<code>cumulative_reserved_amount</code>  <code>property</code>","text":"<p>Returns a list of reserved amounts (incurred minus paid) at each development month.</p>"},{"location":"claims/#pyre.claims.claims.ClaimYearType","title":"<code>ClaimYearType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of claim year types used in insurance data analysis.</p> <p>Attributes:</p> Name Type Description <code>ACCIDENT_YEAR</code> <p>Represents the year in which the insured event (accident) occurred.</p> <code>UNDERWRITING_YEAR</code> <p>Represents the year in which the insurance policy was underwritten or issued.</p> <code>REPORTED_YEAR</code> <p>Represents the year in which the claim was reported to the insurer.</p> Source code in <code>src\\pyre\\claims\\claims.py</code> <pre><code>class ClaimYearType(Enum):\n    \"\"\"Enumeration of claim year types used in insurance data analysis.\n\n    Attributes:\n        ACCIDENT_YEAR: Represents the year in which the insured event (accident) occurred.\n        UNDERWRITING_YEAR: Represents the year in which the insurance policy was underwritten or issued.\n        REPORTED_YEAR: Represents the year in which the claim was reported to the insurer.\n    \"\"\"\n    ACCIDENT_YEAR = auto()\n    UNDERWRITING_YEAR = auto()\n    REPORTED_YEAR = auto()\n</code></pre>"},{"location":"claims/#pyre.claims.claims.Claims","title":"<code>Claims</code>","text":"<p>A container class for managing a collection of Claim objects.</p> <p>This class provides convenient accessors and methods for working with a list of claims, including retrieving modelling years, development periods, and currencies represented in the claims. It also supports list-like behaviors such as indexing, slicing, appending, and iteration.</p> <p>Attributes:</p> Name Type Description <code>claims</code> <code>list[Claim]</code> <p>The list of Claim objects managed by this container.</p> Properties <p>modelling_years (List): Sorted list of unique modelling years across all claims. development_periods (List): Sorted list of unique development periods (in months) across all claims. currencies (Set): Set of unique currencies represented in the claims.</p> <p>Methods:</p> Name Description <code>append</code> <p>Claim): Appends a Claim object to the collection.</p> <code>__getitem__</code> <p>Supports indexing and slicing to access claims.</p> <code>__iter__</code> <p>Returns an iterator over the claims.</p> <code>__len__</code> <p>Returns the number of claims in the collection.</p> Source code in <code>src\\pyre\\claims\\claims.py</code> <pre><code>class Claims:\n    \"\"\"A container class for managing a collection of Claim objects.\n\n    This class provides convenient accessors and methods for working with a list of claims,\n    including retrieving modelling years, development periods, and currencies represented in the claims.\n    It also supports list-like behaviors such as indexing, slicing, appending, and iteration.\n\n    Attributes:\n        claims (list[Claim]): The list of Claim objects managed by this container.\n\n    Properties:\n        modelling_years (List): Sorted list of unique modelling years across all claims.\n        development_periods (List): Sorted list of unique development periods (in months) across all claims.\n        currencies (Set): Set of unique currencies represented in the claims.\n\n    Methods:\n        append(claim: Claim): Appends a Claim object to the collection.\n        __getitem__(key): Supports indexing and slicing to access claims.\n        __iter__(): Returns an iterator over the claims.\n        __len__(): Returns the number of claims in the collection.\n    \"\"\"\n    def __init__(self, claims: list[Claim]) -&gt; None:\n        self._claims = claims\n\n    @property\n    def claims(self):\n        return self._claims\n\n    @claims.setter\n    def claims(self, list_of_claim_classes:list[Claim]):\n        self._claims = list_of_claim_classes\n\n    @property\n    def modelling_years(self) -&gt; List:\n        \"\"\"\n        Returns a list of modelling years for all claims.\n        \"\"\"\n        years = {claim.claims_meta_data.modelling_year for claim in self.claims}\n        return sorted(years)\n\n    @property\n    def development_periods(self) -&gt; List:\n        \"\"\"\n        Returns a sorted list of unique development period sequences across all claims.\n\n        Each element in the returned list is a list of development months from a claim.\n        \"\"\"\n        dev_periods = {tuple(claim.capped_claim_development_history.development_months) for claim in self.claims}\n        return sorted([list(period) for period in dev_periods])\n\n    @property\n    def currencies(self) -&gt; Set:\n        \"\"\"\n        Returns a list of currencies for all claims.\n        \"\"\"\n        return {claim.claims_meta_data.currency for claim in self.claims}\n\n    def append(self, claim: Claim):\n        self._claims.append(claim)\n\n    def __getitem__(self, key):\n        if isinstance(key,slice):\n            cls = type(self)\n            return cls(self._claims[key])\n        index = operator.index(key)\n        return self._claims[index]\n\n    def __iter__(self):\n        return iter(self._claims)\n\n    def __len__(self):\n        return len(self._claims)\n</code></pre>"},{"location":"claims/#pyre.claims.claims.Claims.currencies","title":"<code>currencies</code>  <code>property</code>","text":"<p>Returns a list of currencies for all claims.</p>"},{"location":"claims/#pyre.claims.claims.Claims.development_periods","title":"<code>development_periods</code>  <code>property</code>","text":"<p>Returns a sorted list of unique development period sequences across all claims.</p> <p>Each element in the returned list is a list of development months from a claim.</p>"},{"location":"claims/#pyre.claims.claims.Claims.modelling_years","title":"<code>modelling_years</code>  <code>property</code>","text":"<p>Returns a list of modelling years for all claims.</p>"},{"location":"claims/#pyre.claims.claims.ClaimsMetaData","title":"<code>ClaimsMetaData</code>","text":"<p>Metadata for an insurance claim, including key dates, financial limits, and classification details.</p> <p>Attributes:</p> Name Type Description <code>claim_id</code> <code>str</code> <p>Unique identifier for the claim.</p> <code>currency</code> <code>str</code> <p>Currency code for the claim amounts.</p> <code>contract_limit</code> <code>float</code> <p>Maximum limit of the insurance contract. Defaults to 0.0.</p> <code>contract_deductible</code> <code>float</code> <p>Deductible amount for the contract. Defaults to 0.0.</p> <code>claim_in_xs_of_deductible</code> <code>bool</code> <p>Indicates if the claim is in excess of the deductible. Defaults to False.</p> <code>claim_year_basis</code> <code>ClaimYearType</code> <p>Basis for determining the claim year (e.g., accident, underwriting, reported). Defaults to ClaimYearType.ACCIDENT_YEAR.</p> <code>loss_date</code> <code>date</code> <p>Date of loss occurrence. Defaults to 1900-01-01.</p> <code>policy_inception_date</code> <code>date</code> <p>Policy inception date. Defaults to 1900-01-01.</p> <code>report_date</code> <code>date</code> <p>Date the claim was reported. Defaults to 1900-01-01.</p> <code>line_of_business</code> <code>Optional[str]</code> <p>Line of business associated with the claim. Defaults to None.</p> <code>status</code> <code>Optional[str]</code> <p>Status of the claim (e.g., \"Open\", \"Closed\"). Defaults to \"Open\".</p> Properties <p>modelling_year (ClaimsException | int): Returns the modelling year based on the claim_year_basis, or raises ClaimsException if required date is missing.</p> Source code in <code>src\\pyre\\claims\\claims.py</code> <pre><code>class ClaimsMetaData:\n    \"\"\"Metadata for an insurance claim, including key dates, financial limits, and classification details.\n\n    Attributes:\n        claim_id (str): Unique identifier for the claim.\n        currency (str): Currency code for the claim amounts.\n        contract_limit (float): Maximum limit of the insurance contract. Defaults to 0.0.\n        contract_deductible (float): Deductible amount for the contract. Defaults to 0.0.\n        claim_in_xs_of_deductible (bool): Indicates if the claim is in excess of the deductible. Defaults to False.\n        claim_year_basis (ClaimYearType): Basis for determining the claim year (e.g., accident, underwriting, reported). Defaults to ClaimYearType.ACCIDENT_YEAR.\n        loss_date (date): Date of loss occurrence. Defaults to 1900-01-01.\n        policy_inception_date (date): Policy inception date. Defaults to 1900-01-01.\n        report_date (date): Date the claim was reported. Defaults to 1900-01-01.\n        line_of_business (Optional[str]): Line of business associated with the claim. Defaults to None.\n        status (Optional[str]): Status of the claim (e.g., \"Open\", \"Closed\"). Defaults to \"Open\".\n\n    Properties:\n        modelling_year (ClaimsException | int): Returns the modelling year based on the claim_year_basis, or raises ClaimsException if required date is missing.\n    \"\"\"\n    def __init__(\n        self,\n        claim_id: str,\n        currency: str,\n        contract_limit: float = 0.0,\n        contract_deductible: float = 0.0,\n        claim_in_xs_of_deductible: bool = False,\n        claim_year_basis: ClaimYearType = ClaimYearType.ACCIDENT_YEAR,\n        loss_date: date = date(day=1, month=1, year=1900),\n        policy_inception_date: date = date(day=1, month=1, year=1900),\n        report_date: date = date(day=1, month=1, year=1900),\n        line_of_business: Optional[str] = None,\n        status: Optional[str] = \"Open\"\n    ):\n        self._claim_id = claim_id\n        self._currency = currency\n        self._contract_limit = contract_limit\n        self._contract_deductible = contract_deductible\n        self._claim_in_xs_of_deductible = claim_in_xs_of_deductible\n        self._claim_year_basis = claim_year_basis\n        self._loss_date = loss_date\n        self._policy_inception_date = policy_inception_date\n        self._report_date = report_date\n        self._line_of_business = line_of_business\n        self._status = status\n\n    @property\n    def claim_id(self):\n        return self._claim_id\n\n    @claim_id.setter\n    def claim_id(self, value):\n        self._claim_id = value\n\n    @property\n    def currency(self):\n        return self._currency\n\n    @currency.setter\n    def currency(self, value):\n        self._currency = value\n\n    @property\n    def contract_limit(self):\n        return self._contract_limit\n\n    @contract_limit.setter\n    def contract_limit(self, value):\n        self._contract_limit = value\n\n    @property\n    def contract_deductible(self):\n        return self._contract_deductible\n\n    @contract_deductible.setter\n    def contract_deductible(self, value):\n        self._contract_deductible = value\n\n    @property\n    def claim_in_xs_of_deductible(self):\n        return self._claim_in_xs_of_deductible\n\n    @claim_in_xs_of_deductible.setter\n    def claim_in_xs_of_deductible(self, value):\n        self._claim_in_xs_of_deductible = value\n\n    @property\n    def claim_year_basis(self):\n        return self._claim_year_basis\n\n    @claim_year_basis.setter\n    def claim_year_basis(self, value):\n        self._claim_year_basis = value\n\n    @property\n    def loss_date(self):\n        return self._loss_date\n\n    @loss_date.setter\n    def loss_date(self, value):\n        self._loss_date = value\n\n    @property\n    def policy_inception_date(self):\n        return self._policy_inception_date\n\n    @policy_inception_date.setter\n    def policy_inception_date(self, value):\n        self._policy_inception_date = value\n\n    @property\n    def report_date(self):\n        return self._report_date\n\n    @report_date.setter\n    def report_date(self, value):\n        self._report_date = value\n\n    @property\n    def line_of_business(self):\n        return self._line_of_business\n\n    @line_of_business.setter\n    def line_of_business(self, value):\n        self._line_of_business = value\n\n    @property\n    def status(self):\n        return self._status\n\n    @status.setter\n    def status(self, value):\n        self._status = value\n\n    @property\n    def modelling_year(self) -&gt; int:\n        \"\"\"\n        Returns the modelling year based on the claim_year_basis.\n\n        Returns:\n            int: The year to use for modelling purposes.\n\n        Raises:\n            ClaimsException: If the required date for the specified claim_year_basis is missing.\n        \"\"\"\n        _modeling_basis_years={\n            ClaimYearType.ACCIDENT_YEAR: self.loss_date.year,\n            ClaimYearType.UNDERWRITING_YEAR: self.policy_inception_date.year,\n            ClaimYearType.REPORTED_YEAR: self.report_date.year\n        }\n        if self.claim_year_basis in _modeling_basis_years:\n            return _modeling_basis_years[self.claim_year_basis]\n        else: \n            raise ClaimsException(\n                claim_id=self.claim_id, \n                message=\"Required date missing from data\"\n                )\n</code></pre>"},{"location":"claims/#pyre.claims.claims.ClaimsMetaData.modelling_year","title":"<code>modelling_year</code>  <code>property</code>","text":"<p>Returns the modelling year based on the claim_year_basis.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The year to use for modelling purposes.</p> <p>Raises:</p> Type Description <code>ClaimsException</code> <p>If the required date for the specified claim_year_basis is missing.</p>"},{"location":"claims/#pyre.claims.triangles.CurveType","title":"<code>CurveType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum representing different types of curves that can be fitted to triangle data.</p> Source code in <code>src\\pyre\\claims\\triangles.py</code> <pre><code>class CurveType(Enum):\n    \"\"\"\n    Enum representing different types of curves that can be fitted to triangle data.\n    \"\"\"\n    EXPONENTIAL = auto()\n    POWER = auto()\n    WEIBULL = auto()\n    INVERSE_POWER = auto()\n    OTHER = auto()\n</code></pre>"},{"location":"claims/#pyre.claims.triangles.IBNERPatternExtractor","title":"<code>IBNERPatternExtractor</code>","text":"<p>Extracts IBNER patterns from either a Claims object or a Triangle object.</p> Source code in <code>src\\pyre\\claims\\triangles.py</code> <pre><code>class IBNERPatternExtractor:\n    \"\"\"\n    Extracts IBNER patterns from either a Claims object or a Triangle object.\n    \"\"\"\n    def __init__(self, triangle: Triangle):\n        self.triangle = triangle.triangle\n        self.origin_years = triangle.origin_years\n        self.dev_periods = triangle.dev_periods\n\n        self.N = {oy: {} for oy in self.origin_years}\n        self.D = {oy: {} for oy in self.origin_years}\n        self._compute_N_and_D()\n\n    def _compute_N_and_D(self):\n        \"\"\"\n        Compute the N and D triangles from cumulative data.\n        \"\"\"\n        for oy in self.origin_years:\n            cumulative = [self.triangle[oy].get(d, None) for d in self.dev_periods]\n            for idx, d in enumerate(self.dev_periods):\n                if idx &gt;= len(cumulative) or cumulative[idx] is None:\n                    self.N[oy][d] = None\n                    self.D[oy][d] = None\n                    continue\n\n                current = cumulative[idx]\n                if idx == 0:\n                    self.N[oy][d] = current\n                    self.D[oy][d] = None\n                else:\n                    prev = cumulative[idx - 1]\n                    if current is None or prev is None:\n                        self.N[oy][d] = None\n                        self.D[oy][d] = None\n                    else:\n                        self.D[oy][d] = prev - current\n                        self.N[oy][d] = current - prev + self.D[oy][d]\n\n    def get_N_triangle(self) -&gt; Dict[int, Dict[int, float]]:\n        \"\"\"\n        Returns the N triangle (new claims).\n        \"\"\"\n        return self.N\n\n    def get_D_triangle(self) -&gt; Dict[int, Dict[int, float]]:\n        \"\"\"\n        Returns the D triangle (IBNER development).\n        \"\"\"\n        return self.D\n\n    def get_IBNER_pattern(self) -&gt; Dict[int, float]:\n        \"\"\"\n        Returns the average D (IBNER) pattern per development year.\n        \"\"\"\n        sums = {d: 0.0 for d in self.dev_periods}\n        counts = {d: 0 for d in self.dev_periods}\n\n        for oy in self.origin_years:\n            for d in self.dev_periods:\n                val = self.D.get(oy, {}).get(d)\n                if val is not None:\n                    sums[d] += val\n                    counts[d] += 1\n\n        return {d: (sums[d] / counts[d]) if counts[d] &gt; 0 else None for d in self.dev_periods}\n</code></pre>"},{"location":"claims/#pyre.claims.triangles.IBNERPatternExtractor.get_D_triangle","title":"<code>get_D_triangle()</code>","text":"<p>Returns the D triangle (IBNER development).</p> Source code in <code>src\\pyre\\claims\\triangles.py</code> <pre><code>def get_D_triangle(self) -&gt; Dict[int, Dict[int, float]]:\n    \"\"\"\n    Returns the D triangle (IBNER development).\n    \"\"\"\n    return self.D\n</code></pre>"},{"location":"claims/#pyre.claims.triangles.IBNERPatternExtractor.get_IBNER_pattern","title":"<code>get_IBNER_pattern()</code>","text":"<p>Returns the average D (IBNER) pattern per development year.</p> Source code in <code>src\\pyre\\claims\\triangles.py</code> <pre><code>def get_IBNER_pattern(self) -&gt; Dict[int, float]:\n    \"\"\"\n    Returns the average D (IBNER) pattern per development year.\n    \"\"\"\n    sums = {d: 0.0 for d in self.dev_periods}\n    counts = {d: 0 for d in self.dev_periods}\n\n    for oy in self.origin_years:\n        for d in self.dev_periods:\n            val = self.D.get(oy, {}).get(d)\n            if val is not None:\n                sums[d] += val\n                counts[d] += 1\n\n    return {d: (sums[d] / counts[d]) if counts[d] &gt; 0 else None for d in self.dev_periods}\n</code></pre>"},{"location":"claims/#pyre.claims.triangles.IBNERPatternExtractor.get_N_triangle","title":"<code>get_N_triangle()</code>","text":"<p>Returns the N triangle (new claims).</p> Source code in <code>src\\pyre\\claims\\triangles.py</code> <pre><code>def get_N_triangle(self) -&gt; Dict[int, Dict[int, float]]:\n    \"\"\"\n    Returns the N triangle (new claims).\n    \"\"\"\n    return self.N\n</code></pre>"},{"location":"claims/#pyre.claims.triangles.Triangle","title":"<code>Triangle</code>","text":"<p>Represents a triangle of claim values (e.g., paid or incurred) by origin (modelling) year and development period.</p> <p>The triangle is stored as a nested dictionary where: - The outer key is the origin year (int) - The inner key is the development period (int) - The value is the claim amount (float)</p> <p>Example structure: {     2020: {1: 100.0, 2: 150.0, 3: 175.0},     2021: {1: 110.0, 2: 165.0},     2022: {1: 120.0} }</p> Source code in <code>src\\pyre\\claims\\triangles.py</code> <pre><code>class Triangle:\n    \"\"\"\n    Represents a triangle of claim values (e.g., paid or incurred) by origin (modelling) year and development period.\n\n    The triangle is stored as a nested dictionary where:\n    - The outer key is the origin year (int)\n    - The inner key is the development period (int)\n    - The value is the claim amount (float)\n\n    Example structure:\n    {\n        2020: {1: 100.0, 2: 150.0, 3: 175.0},\n        2021: {1: 110.0, 2: 165.0},\n        2022: {1: 120.0}\n    }\n    \"\"\"\n\n    def __init__(\n        self,\n        triangle: Optional[Dict[int, Dict[int, float]]] = None,\n        origin_years: Optional[List[int]] = None,\n        dev_periods: Optional[List[int]] = None,\n    ):\n        \"\"\"\n        Initialize a Triangle directly or as an empty structure.\n\n        Args:\n            triangle: Dictionary mapping origin years to dictionaries mapping development periods to values\n            origin_years: List of origin years in the triangle\n            dev_periods: List of development periods in the triangle\n        \"\"\"\n        self.triangle = triangle if triangle is not None else {}\n\n        # If origin_years not provided, extract from triangle keys\n        if origin_years is None:\n            self.origin_years = sorted(self.triangle.keys()) if self.triangle else []\n        else:\n            self.origin_years = sorted(origin_years)\n\n        # If dev_periods not provided, extract from all inner dictionaries\n        if dev_periods is None:\n            all_dev_periods = set()\n            for year_data in self.triangle.values():\n                all_dev_periods.update(year_data.keys())\n            self.dev_periods = sorted(all_dev_periods) if all_dev_periods else []\n        else:\n            self.dev_periods = sorted(dev_periods)\n\n        # Validate the triangle structure\n        self._validate_triangle()\n\n    def _validate_triangle(self) -&gt; None:\n        \"\"\"\n        Validate the triangle structure to ensure all keys are integers\n        and all values are numeric.\n\n        Raises:\n            ValueError: If the triangle structure is invalid\n        \"\"\"\n        for origin_year, dev_data in self.triangle.items():\n            if not isinstance(origin_year, int):\n                raise ValueError(f\"Origin year must be an integer, got {type(origin_year)}\")\n\n            for dev_period, value in dev_data.items():\n                if not isinstance(dev_period, int):\n                    raise ValueError(f\"Development period must be an integer, got {type(dev_period)}\")\n\n                if value is not None and not isinstance(value, (int, float)):\n                    raise ValueError(f\"Triangle values must be numeric or None, got {type(value)}\")\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of the Triangle object.\"\"\"\n        return f\"Triangle(origin_years={self.origin_years}, dev_periods={self.dev_periods})\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a formatted string representation of the triangle.\"\"\"\n        if not self.triangle:\n            return \"Empty Triangle\"\n\n        # Create header row\n        header = \"Origin Year | \" + \" | \".join(f\"Dev {d}\" for d in self.dev_periods)\n\n        # Create rows for each origin year\n        rows = []\n        for oy in self.origin_years:\n            row_values = []\n            for dp in self.dev_periods:\n                value = self.triangle.get(oy, {}).get(dp)\n                row_values.append(f\"{value:.2f}\" if value is not None else \"N/A\")\n            rows.append(f\"{oy} | \" + \" | \".join(row_values))\n\n        return header + \"\\n\" + \"\\n\".join(rows)\n\n    def __getitem__(self, key: Tuple[int, int]) -&gt; Optional[float]:\n        \"\"\"\n        Get a value from the triangle using tuple indexing.\n\n        Args:\n            key: Tuple of (origin_year, development_period)\n\n        Returns:\n            The value at the specified position or None if not found\n\n        Example:\n            value = triangle[2020, 2]  # Gets the value for origin year 2020, development period 2\n        \"\"\"\n        origin_year, dev_period = key\n        return self.triangle.get(origin_year, {}).get(dev_period)\n\n    def __setitem__(self, key: Tuple[int, int], value: Optional[float]) -&gt; None:\n        \"\"\"\n        Set a value in the triangle using tuple indexing.\n\n        Args:\n            key: Tuple of (origin_year, development_period)\n            value: The value to set\n\n        Example:\n            triangle[2020, 2] = 150.0  # Sets the value for origin year 2020, development period 2\n        \"\"\"\n        origin_year, dev_period = key\n\n        # Ensure the origin year exists in the triangle\n        if origin_year not in self.triangle:\n            self.triangle[origin_year] = {}\n            if origin_year not in self.origin_years:\n                self.origin_years.append(origin_year)\n                self.origin_years.sort()\n\n        # Set the value\n        self.triangle[origin_year][dev_period] = value\n\n        # Update dev_periods if needed\n        if dev_period not in self.dev_periods:\n            self.dev_periods.append(dev_period)\n            self.dev_periods.sort()\n\n    def get_value(self, origin_year: int, dev_period: int) -&gt; Optional[float]:\n        \"\"\"\n        Get a value from the triangle.\n\n        Args:\n            origin_year: The origin year\n            dev_period: The development period\n\n        Returns:\n            The value at the specified position or None if not found\n        \"\"\"\n        return self.triangle.get(origin_year, {}).get(dev_period)\n\n    def set_value(self, origin_year: int, dev_period: int, value: Optional[float]) -&gt; None:\n        \"\"\"\n        Set a value in the triangle.\n\n        Args:\n            origin_year: The origin year\n            dev_period: The development period\n            value: The value to set\n        \"\"\"\n        self[origin_year, dev_period] = value\n\n    def get_latest_diagonal(self) -&gt; Dict[int, float]:\n        \"\"\"\n        Get the latest diagonal of the triangle.\n\n        Returns:\n            Dictionary mapping origin years to their latest available values\n        \"\"\"\n        result = {}\n        for oy in self.origin_years:\n            # Find the maximum development period with a value for this origin year\n            available_devs = [dp for dp in self.dev_periods if self.get_value(oy, dp) is not None]\n            if available_devs:\n                max_dev = max(available_devs)\n                result[oy] = self.get_value(oy, max_dev)\n        return result\n\n    def to_incremental(self) -&gt; 'Triangle':\n        \"\"\"\n        Convert a cumulative triangle to an incremental triangle.\n\n        Returns:\n            A new Triangle with incremental values\n        \"\"\"\n        incremental_triangle = {}\n\n        for oy in self.origin_years:\n            incremental_triangle[oy] = {}\n            prev_value = None\n\n            for dp in self.dev_periods:\n                current_value = self.get_value(oy, dp)\n\n                if current_value is None:\n                    incremental_triangle[oy][dp] = None\n                elif prev_value is None:\n                    incremental_triangle[oy][dp] = current_value\n                else:\n                    incremental_triangle[oy][dp] = current_value - prev_value\n\n                if current_value is not None:\n                    prev_value = current_value\n\n        return Triangle(\n            triangle=incremental_triangle,\n            origin_years=self.origin_years.copy(),\n            dev_periods=self.dev_periods.copy()\n        )\n\n    def to_cumulative(self) -&gt; 'Triangle':\n        \"\"\"\n        Convert an incremental triangle to a cumulative triangle.\n\n        Returns:\n            A new Triangle with cumulative values\n        \"\"\"\n        cumulative_triangle = {}\n\n        for oy in self.origin_years:\n            cumulative_triangle[oy] = {}\n            cumulative_value = 0.0\n\n            for dp in self.dev_periods:\n                incremental_value = self.get_value(oy, dp)\n\n                if incremental_value is None:\n                    cumulative_triangle[oy][dp] = None\n                else:\n                    cumulative_value += incremental_value\n                    cumulative_triangle[oy][dp] = cumulative_value\n\n        return Triangle(\n            triangle=cumulative_triangle,\n            origin_years=self.origin_years.copy(),\n            dev_periods=self.dev_periods.copy()\n        )\n\n    @classmethod\n    def from_claims(cls, claims: Claims, value_type: str = \"incurred\") -&gt; \"Triangle\":\n        \"\"\"\n        Construct a Triangle from a Claims object.\n\n        Args:\n            claims: Claims object containing claim data\n            value_type: Type of values to extract, either \"incurred\" or \"paid\"\n\n        Returns:\n            A new Triangle object with aggregated claim values\n\n        Raises:\n            ValueError: If value_type is not \"incurred\" or \"paid\"\n        \"\"\"\n        if value_type not in [\"incurred\", \"paid\"]:\n            raise ValueError(f\"value_type must be 'incurred' or 'paid', got '{value_type}'\")\n\n        # Collect all unique modelling years and development periods\n        origin_years = claims.modelling_years\n        dev_periods = claims.development_periods\n\n        # Build the triangle\n        triangle = {year: {} for year in origin_years}\n\n        # Aggregate claims by origin year and development period\n        for claim in claims:\n            origin_year = claim.modelling_year\n\n            # Skip claims with no development history\n            if not hasattr(claim, 'capped_claim_development_history'):\n                continue\n\n            # Get the appropriate development history based on value_type\n            if value_type == \"incurred\":\n                dev_history = claim.capped_claim_development_history.cumulative_dev_incurred\n            else:  # value_type == \"paid\"\n                dev_history = claim.capped_claim_development_history.cumulative_dev_paid\n\n            # Add values to the triangle\n            for dev_period, value in dev_history.items():\n                if dev_period in dev_periods:\n                    if dev_period not in triangle[origin_year]:\n                        triangle[origin_year][dev_period] = 0.0\n                    triangle[origin_year][dev_period] += value\n\n        return cls(triangle=triangle, origin_years=origin_years, dev_periods=dev_periods)\n\n    def calculate_age_to_age_factors(self) -&gt; Dict[int, Dict[int, float]]:\n        \"\"\"\n        Calculate age-to-age factors for the triangle.\n\n        Age-to-age factors are calculated as the ratio of the value at development period j+1\n        to the value at development period j for each origin year.\n\n        Returns:\n            Dict[int, Dict[int, float]]: A dictionary mapping origin years to dictionaries\n                mapping development periods to age-to-age factors.\n        \"\"\"\n        factors = {}\n\n        for oy in self.origin_years:\n            factors[oy] = {}\n            for i in range(len(self.dev_periods) - 1):\n                current_dev = self.dev_periods[i]\n                next_dev = self.dev_periods[i + 1]\n\n                current_value = self.get_value(oy, current_dev)\n                next_value = self.get_value(oy, next_dev)\n\n                if current_value is not None and next_value is not None and current_value != 0:\n                    factors[oy][current_dev] = next_value / current_value\n\n        return factors\n\n    def get_average_age_to_age_factors(self, method: str = \"simple\") -&gt; Dict[int, float]:\n        \"\"\"\n        Calculate average age-to-age factors across all origin years.\n\n        Args:\n            method (str): Method to use for averaging. Options are:\n                - \"simple\": Simple arithmetic mean\n                - \"volume\": Volume-weighted average\n\n        Returns:\n            Dict[int, float]: A dictionary mapping development periods to average age-to-age factors.\n        \"\"\"\n        factors = self.calculate_age_to_age_factors()\n        avg_factors = {}\n\n        for dev_idx in range(len(self.dev_periods) - 1):\n            dev = self.dev_periods[dev_idx]\n\n            if method == \"simple\":\n                # Simple average\n                dev_factors = [factors[oy].get(dev) for oy in self.origin_years if dev in factors.get(oy, {})]\n                dev_factors = [f for f in dev_factors if f is not None]\n\n                if dev_factors:\n                    avg_factors[dev] = sum(dev_factors) / len(dev_factors)\n\n            elif method == \"volume\":\n                # Volume-weighted average\n                numerator_sum = 0.0\n                denominator_sum = 0.0\n\n                for oy in self.origin_years:\n                    current_value = self.get_value(oy, dev)\n                    next_value = self.get_value(oy, self.dev_periods[dev_idx + 1])\n\n                    if current_value is not None and next_value is not None and current_value != 0:\n                        numerator_sum += next_value\n                        denominator_sum += current_value\n\n                if denominator_sum != 0:\n                    avg_factors[dev] = numerator_sum / denominator_sum\n\n        return avg_factors\n\n    def fit_curve(self, curve_type: CurveType, c_values: List[float] = None) -&gt; Tuple[Dict[str, float], Dict[str, float]]:\n        \"\"\"\n        Fit a curve to the average age-to-age factors.\n\n        Args:\n            curve_type (CurveType): Type of curve to fit. Options are:\n                - CurveType.EXPONENTIAL: Exponential curve\n                - CurveType.POWER: Power curve\n                - CurveType.WEIBULL: Weibull curve\n                - CurveType.INVERSE_POWER: Inverse power curve (Sherman)\n            c_values (List[float], optional): List of candidate c values for inverse power fit.\n                Defaults to [0.5, 1.0, 1.5, 2.0, 2.5, 3.0].\n\n        Returns:\n            Tuple[Dict[str, float], Dict[str, float]]: A tuple containing:\n                - Parameters of the fitted curve\n                - Metrics assessing the quality of the fit\n        \"\"\"\n        if c_values is None:\n            c_values = [0.5, 1.0, 1.5, 2.0, 2.5, 3.0]\n\n        # Get average age-to-age factors\n        avg_factors = self.get_average_age_to_age_factors()\n\n        # Prepare data for curve fitting\n        dev_periods = sorted(avg_factors.keys())\n        factors = [avg_factors[dp] for dp in dev_periods]\n\n        # Fit the appropriate curve\n        if curve_type == CurveType.EXPONENTIAL:\n            a, b = exponential_fit(factors, dev_periods)\n            params = {\"a\": a, \"b\": b}\n            expected = [1 + exp(a + b * dp) for dp in dev_periods]\n            num_params = 2\n\n        elif curve_type == CurveType.POWER:\n            a, b = power_fit(factors, dev_periods)\n            params = {\"a\": a, \"b\": b}\n            expected = [a * (b ** dp) for dp in dev_periods]\n            num_params = 2\n\n        elif curve_type == CurveType.WEIBULL:\n            a, b = weibull_fit(factors, dev_periods)\n            params = {\"a\": a, \"b\": b}\n            expected = [1 / (1 - exp(-a * (dp ** b))) for dp in dev_periods]\n            num_params = 2\n\n        elif curve_type == CurveType.INVERSE_POWER:\n            a, b, c = inverse_power_fit(factors, dev_periods, c_values)\n            params = {\"a\": a, \"b\": b, \"c\": c}\n            expected = [1 + a * ((dp + c) ** b) for dp in dev_periods]\n            num_params = 3\n\n        else:\n            raise ValueError(f\"Unknown curve type: {curve_type}\")\n\n        # Calculate fit metrics\n        r_squared_value = r_squared(factors, expected)\n        error_metrics = assess_error_assumptions(factors, expected, num_params)\n\n        metrics = {\n            \"r_squared\": r_squared_value,\n            **error_metrics\n        }\n\n        return params, metrics\n</code></pre>"},{"location":"claims/#pyre.claims.triangles.Triangle.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Get a value from the triangle using tuple indexing.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Tuple[int, int]</code> <p>Tuple of (origin_year, development_period)</p> required <p>Returns:</p> Type Description <code>Optional[float]</code> <p>The value at the specified position or None if not found</p> Example <p>value = triangle[2020, 2]  # Gets the value for origin year 2020, development period 2</p> Source code in <code>src\\pyre\\claims\\triangles.py</code> <pre><code>def __getitem__(self, key: Tuple[int, int]) -&gt; Optional[float]:\n    \"\"\"\n    Get a value from the triangle using tuple indexing.\n\n    Args:\n        key: Tuple of (origin_year, development_period)\n\n    Returns:\n        The value at the specified position or None if not found\n\n    Example:\n        value = triangle[2020, 2]  # Gets the value for origin year 2020, development period 2\n    \"\"\"\n    origin_year, dev_period = key\n    return self.triangle.get(origin_year, {}).get(dev_period)\n</code></pre>"},{"location":"claims/#pyre.claims.triangles.Triangle.__init__","title":"<code>__init__(triangle=None, origin_years=None, dev_periods=None)</code>","text":"<p>Initialize a Triangle directly or as an empty structure.</p> <p>Parameters:</p> Name Type Description Default <code>triangle</code> <code>Optional[Dict[int, Dict[int, float]]]</code> <p>Dictionary mapping origin years to dictionaries mapping development periods to values</p> <code>None</code> <code>origin_years</code> <code>Optional[List[int]]</code> <p>List of origin years in the triangle</p> <code>None</code> <code>dev_periods</code> <code>Optional[List[int]]</code> <p>List of development periods in the triangle</p> <code>None</code> Source code in <code>src\\pyre\\claims\\triangles.py</code> <pre><code>def __init__(\n    self,\n    triangle: Optional[Dict[int, Dict[int, float]]] = None,\n    origin_years: Optional[List[int]] = None,\n    dev_periods: Optional[List[int]] = None,\n):\n    \"\"\"\n    Initialize a Triangle directly or as an empty structure.\n\n    Args:\n        triangle: Dictionary mapping origin years to dictionaries mapping development periods to values\n        origin_years: List of origin years in the triangle\n        dev_periods: List of development periods in the triangle\n    \"\"\"\n    self.triangle = triangle if triangle is not None else {}\n\n    # If origin_years not provided, extract from triangle keys\n    if origin_years is None:\n        self.origin_years = sorted(self.triangle.keys()) if self.triangle else []\n    else:\n        self.origin_years = sorted(origin_years)\n\n    # If dev_periods not provided, extract from all inner dictionaries\n    if dev_periods is None:\n        all_dev_periods = set()\n        for year_data in self.triangle.values():\n            all_dev_periods.update(year_data.keys())\n        self.dev_periods = sorted(all_dev_periods) if all_dev_periods else []\n    else:\n        self.dev_periods = sorted(dev_periods)\n\n    # Validate the triangle structure\n    self._validate_triangle()\n</code></pre>"},{"location":"claims/#pyre.claims.triangles.Triangle.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the Triangle object.</p> Source code in <code>src\\pyre\\claims\\triangles.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of the Triangle object.\"\"\"\n    return f\"Triangle(origin_years={self.origin_years}, dev_periods={self.dev_periods})\"\n</code></pre>"},{"location":"claims/#pyre.claims.triangles.Triangle.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Set a value in the triangle using tuple indexing.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Tuple[int, int]</code> <p>Tuple of (origin_year, development_period)</p> required <code>value</code> <code>Optional[float]</code> <p>The value to set</p> required Example <p>triangle[2020, 2] = 150.0  # Sets the value for origin year 2020, development period 2</p> Source code in <code>src\\pyre\\claims\\triangles.py</code> <pre><code>def __setitem__(self, key: Tuple[int, int], value: Optional[float]) -&gt; None:\n    \"\"\"\n    Set a value in the triangle using tuple indexing.\n\n    Args:\n        key: Tuple of (origin_year, development_period)\n        value: The value to set\n\n    Example:\n        triangle[2020, 2] = 150.0  # Sets the value for origin year 2020, development period 2\n    \"\"\"\n    origin_year, dev_period = key\n\n    # Ensure the origin year exists in the triangle\n    if origin_year not in self.triangle:\n        self.triangle[origin_year] = {}\n        if origin_year not in self.origin_years:\n            self.origin_years.append(origin_year)\n            self.origin_years.sort()\n\n    # Set the value\n    self.triangle[origin_year][dev_period] = value\n\n    # Update dev_periods if needed\n    if dev_period not in self.dev_periods:\n        self.dev_periods.append(dev_period)\n        self.dev_periods.sort()\n</code></pre>"},{"location":"claims/#pyre.claims.triangles.Triangle.__str__","title":"<code>__str__()</code>","text":"<p>Return a formatted string representation of the triangle.</p> Source code in <code>src\\pyre\\claims\\triangles.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a formatted string representation of the triangle.\"\"\"\n    if not self.triangle:\n        return \"Empty Triangle\"\n\n    # Create header row\n    header = \"Origin Year | \" + \" | \".join(f\"Dev {d}\" for d in self.dev_periods)\n\n    # Create rows for each origin year\n    rows = []\n    for oy in self.origin_years:\n        row_values = []\n        for dp in self.dev_periods:\n            value = self.triangle.get(oy, {}).get(dp)\n            row_values.append(f\"{value:.2f}\" if value is not None else \"N/A\")\n        rows.append(f\"{oy} | \" + \" | \".join(row_values))\n\n    return header + \"\\n\" + \"\\n\".join(rows)\n</code></pre>"},{"location":"claims/#pyre.claims.triangles.Triangle.calculate_age_to_age_factors","title":"<code>calculate_age_to_age_factors()</code>","text":"<p>Calculate age-to-age factors for the triangle.</p> <p>Age-to-age factors are calculated as the ratio of the value at development period j+1 to the value at development period j for each origin year.</p> <p>Returns:</p> Type Description <code>Dict[int, Dict[int, float]]</code> <p>Dict[int, Dict[int, float]]: A dictionary mapping origin years to dictionaries mapping development periods to age-to-age factors.</p> Source code in <code>src\\pyre\\claims\\triangles.py</code> <pre><code>def calculate_age_to_age_factors(self) -&gt; Dict[int, Dict[int, float]]:\n    \"\"\"\n    Calculate age-to-age factors for the triangle.\n\n    Age-to-age factors are calculated as the ratio of the value at development period j+1\n    to the value at development period j for each origin year.\n\n    Returns:\n        Dict[int, Dict[int, float]]: A dictionary mapping origin years to dictionaries\n            mapping development periods to age-to-age factors.\n    \"\"\"\n    factors = {}\n\n    for oy in self.origin_years:\n        factors[oy] = {}\n        for i in range(len(self.dev_periods) - 1):\n            current_dev = self.dev_periods[i]\n            next_dev = self.dev_periods[i + 1]\n\n            current_value = self.get_value(oy, current_dev)\n            next_value = self.get_value(oy, next_dev)\n\n            if current_value is not None and next_value is not None and current_value != 0:\n                factors[oy][current_dev] = next_value / current_value\n\n    return factors\n</code></pre>"},{"location":"claims/#pyre.claims.triangles.Triangle.fit_curve","title":"<code>fit_curve(curve_type, c_values=None)</code>","text":"<p>Fit a curve to the average age-to-age factors.</p> <p>Parameters:</p> Name Type Description Default <code>curve_type</code> <code>CurveType</code> <p>Type of curve to fit. Options are: - CurveType.EXPONENTIAL: Exponential curve - CurveType.POWER: Power curve - CurveType.WEIBULL: Weibull curve - CurveType.INVERSE_POWER: Inverse power curve (Sherman)</p> required <code>c_values</code> <code>List[float]</code> <p>List of candidate c values for inverse power fit. Defaults to [0.5, 1.0, 1.5, 2.0, 2.5, 3.0].</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[Dict[str, float], Dict[str, float]]</code> <p>Tuple[Dict[str, float], Dict[str, float]]: A tuple containing: - Parameters of the fitted curve - Metrics assessing the quality of the fit</p> Source code in <code>src\\pyre\\claims\\triangles.py</code> <pre><code>def fit_curve(self, curve_type: CurveType, c_values: List[float] = None) -&gt; Tuple[Dict[str, float], Dict[str, float]]:\n    \"\"\"\n    Fit a curve to the average age-to-age factors.\n\n    Args:\n        curve_type (CurveType): Type of curve to fit. Options are:\n            - CurveType.EXPONENTIAL: Exponential curve\n            - CurveType.POWER: Power curve\n            - CurveType.WEIBULL: Weibull curve\n            - CurveType.INVERSE_POWER: Inverse power curve (Sherman)\n        c_values (List[float], optional): List of candidate c values for inverse power fit.\n            Defaults to [0.5, 1.0, 1.5, 2.0, 2.5, 3.0].\n\n    Returns:\n        Tuple[Dict[str, float], Dict[str, float]]: A tuple containing:\n            - Parameters of the fitted curve\n            - Metrics assessing the quality of the fit\n    \"\"\"\n    if c_values is None:\n        c_values = [0.5, 1.0, 1.5, 2.0, 2.5, 3.0]\n\n    # Get average age-to-age factors\n    avg_factors = self.get_average_age_to_age_factors()\n\n    # Prepare data for curve fitting\n    dev_periods = sorted(avg_factors.keys())\n    factors = [avg_factors[dp] for dp in dev_periods]\n\n    # Fit the appropriate curve\n    if curve_type == CurveType.EXPONENTIAL:\n        a, b = exponential_fit(factors, dev_periods)\n        params = {\"a\": a, \"b\": b}\n        expected = [1 + exp(a + b * dp) for dp in dev_periods]\n        num_params = 2\n\n    elif curve_type == CurveType.POWER:\n        a, b = power_fit(factors, dev_periods)\n        params = {\"a\": a, \"b\": b}\n        expected = [a * (b ** dp) for dp in dev_periods]\n        num_params = 2\n\n    elif curve_type == CurveType.WEIBULL:\n        a, b = weibull_fit(factors, dev_periods)\n        params = {\"a\": a, \"b\": b}\n        expected = [1 / (1 - exp(-a * (dp ** b))) for dp in dev_periods]\n        num_params = 2\n\n    elif curve_type == CurveType.INVERSE_POWER:\n        a, b, c = inverse_power_fit(factors, dev_periods, c_values)\n        params = {\"a\": a, \"b\": b, \"c\": c}\n        expected = [1 + a * ((dp + c) ** b) for dp in dev_periods]\n        num_params = 3\n\n    else:\n        raise ValueError(f\"Unknown curve type: {curve_type}\")\n\n    # Calculate fit metrics\n    r_squared_value = r_squared(factors, expected)\n    error_metrics = assess_error_assumptions(factors, expected, num_params)\n\n    metrics = {\n        \"r_squared\": r_squared_value,\n        **error_metrics\n    }\n\n    return params, metrics\n</code></pre>"},{"location":"claims/#pyre.claims.triangles.Triangle.from_claims","title":"<code>from_claims(claims, value_type='incurred')</code>  <code>classmethod</code>","text":"<p>Construct a Triangle from a Claims object.</p> <p>Parameters:</p> Name Type Description Default <code>claims</code> <code>Claims</code> <p>Claims object containing claim data</p> required <code>value_type</code> <code>str</code> <p>Type of values to extract, either \"incurred\" or \"paid\"</p> <code>'incurred'</code> <p>Returns:</p> Type Description <code>Triangle</code> <p>A new Triangle object with aggregated claim values</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If value_type is not \"incurred\" or \"paid\"</p> Source code in <code>src\\pyre\\claims\\triangles.py</code> <pre><code>@classmethod\ndef from_claims(cls, claims: Claims, value_type: str = \"incurred\") -&gt; \"Triangle\":\n    \"\"\"\n    Construct a Triangle from a Claims object.\n\n    Args:\n        claims: Claims object containing claim data\n        value_type: Type of values to extract, either \"incurred\" or \"paid\"\n\n    Returns:\n        A new Triangle object with aggregated claim values\n\n    Raises:\n        ValueError: If value_type is not \"incurred\" or \"paid\"\n    \"\"\"\n    if value_type not in [\"incurred\", \"paid\"]:\n        raise ValueError(f\"value_type must be 'incurred' or 'paid', got '{value_type}'\")\n\n    # Collect all unique modelling years and development periods\n    origin_years = claims.modelling_years\n    dev_periods = claims.development_periods\n\n    # Build the triangle\n    triangle = {year: {} for year in origin_years}\n\n    # Aggregate claims by origin year and development period\n    for claim in claims:\n        origin_year = claim.modelling_year\n\n        # Skip claims with no development history\n        if not hasattr(claim, 'capped_claim_development_history'):\n            continue\n\n        # Get the appropriate development history based on value_type\n        if value_type == \"incurred\":\n            dev_history = claim.capped_claim_development_history.cumulative_dev_incurred\n        else:  # value_type == \"paid\"\n            dev_history = claim.capped_claim_development_history.cumulative_dev_paid\n\n        # Add values to the triangle\n        for dev_period, value in dev_history.items():\n            if dev_period in dev_periods:\n                if dev_period not in triangle[origin_year]:\n                    triangle[origin_year][dev_period] = 0.0\n                triangle[origin_year][dev_period] += value\n\n    return cls(triangle=triangle, origin_years=origin_years, dev_periods=dev_periods)\n</code></pre>"},{"location":"claims/#pyre.claims.triangles.Triangle.get_average_age_to_age_factors","title":"<code>get_average_age_to_age_factors(method='simple')</code>","text":"<p>Calculate average age-to-age factors across all origin years.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>Method to use for averaging. Options are: - \"simple\": Simple arithmetic mean - \"volume\": Volume-weighted average</p> <code>'simple'</code> <p>Returns:</p> Type Description <code>Dict[int, float]</code> <p>Dict[int, float]: A dictionary mapping development periods to average age-to-age factors.</p> Source code in <code>src\\pyre\\claims\\triangles.py</code> <pre><code>def get_average_age_to_age_factors(self, method: str = \"simple\") -&gt; Dict[int, float]:\n    \"\"\"\n    Calculate average age-to-age factors across all origin years.\n\n    Args:\n        method (str): Method to use for averaging. Options are:\n            - \"simple\": Simple arithmetic mean\n            - \"volume\": Volume-weighted average\n\n    Returns:\n        Dict[int, float]: A dictionary mapping development periods to average age-to-age factors.\n    \"\"\"\n    factors = self.calculate_age_to_age_factors()\n    avg_factors = {}\n\n    for dev_idx in range(len(self.dev_periods) - 1):\n        dev = self.dev_periods[dev_idx]\n\n        if method == \"simple\":\n            # Simple average\n            dev_factors = [factors[oy].get(dev) for oy in self.origin_years if dev in factors.get(oy, {})]\n            dev_factors = [f for f in dev_factors if f is not None]\n\n            if dev_factors:\n                avg_factors[dev] = sum(dev_factors) / len(dev_factors)\n\n        elif method == \"volume\":\n            # Volume-weighted average\n            numerator_sum = 0.0\n            denominator_sum = 0.0\n\n            for oy in self.origin_years:\n                current_value = self.get_value(oy, dev)\n                next_value = self.get_value(oy, self.dev_periods[dev_idx + 1])\n\n                if current_value is not None and next_value is not None and current_value != 0:\n                    numerator_sum += next_value\n                    denominator_sum += current_value\n\n            if denominator_sum != 0:\n                avg_factors[dev] = numerator_sum / denominator_sum\n\n    return avg_factors\n</code></pre>"},{"location":"claims/#pyre.claims.triangles.Triangle.get_latest_diagonal","title":"<code>get_latest_diagonal()</code>","text":"<p>Get the latest diagonal of the triangle.</p> <p>Returns:</p> Type Description <code>Dict[int, float]</code> <p>Dictionary mapping origin years to their latest available values</p> Source code in <code>src\\pyre\\claims\\triangles.py</code> <pre><code>def get_latest_diagonal(self) -&gt; Dict[int, float]:\n    \"\"\"\n    Get the latest diagonal of the triangle.\n\n    Returns:\n        Dictionary mapping origin years to their latest available values\n    \"\"\"\n    result = {}\n    for oy in self.origin_years:\n        # Find the maximum development period with a value for this origin year\n        available_devs = [dp for dp in self.dev_periods if self.get_value(oy, dp) is not None]\n        if available_devs:\n            max_dev = max(available_devs)\n            result[oy] = self.get_value(oy, max_dev)\n    return result\n</code></pre>"},{"location":"claims/#pyre.claims.triangles.Triangle.get_value","title":"<code>get_value(origin_year, dev_period)</code>","text":"<p>Get a value from the triangle.</p> <p>Parameters:</p> Name Type Description Default <code>origin_year</code> <code>int</code> <p>The origin year</p> required <code>dev_period</code> <code>int</code> <p>The development period</p> required <p>Returns:</p> Type Description <code>Optional[float]</code> <p>The value at the specified position or None if not found</p> Source code in <code>src\\pyre\\claims\\triangles.py</code> <pre><code>def get_value(self, origin_year: int, dev_period: int) -&gt; Optional[float]:\n    \"\"\"\n    Get a value from the triangle.\n\n    Args:\n        origin_year: The origin year\n        dev_period: The development period\n\n    Returns:\n        The value at the specified position or None if not found\n    \"\"\"\n    return self.triangle.get(origin_year, {}).get(dev_period)\n</code></pre>"},{"location":"claims/#pyre.claims.triangles.Triangle.set_value","title":"<code>set_value(origin_year, dev_period, value)</code>","text":"<p>Set a value in the triangle.</p> <p>Parameters:</p> Name Type Description Default <code>origin_year</code> <code>int</code> <p>The origin year</p> required <code>dev_period</code> <code>int</code> <p>The development period</p> required <code>value</code> <code>Optional[float]</code> <p>The value to set</p> required Source code in <code>src\\pyre\\claims\\triangles.py</code> <pre><code>def set_value(self, origin_year: int, dev_period: int, value: Optional[float]) -&gt; None:\n    \"\"\"\n    Set a value in the triangle.\n\n    Args:\n        origin_year: The origin year\n        dev_period: The development period\n        value: The value to set\n    \"\"\"\n    self[origin_year, dev_period] = value\n</code></pre>"},{"location":"claims/#pyre.claims.triangles.Triangle.to_cumulative","title":"<code>to_cumulative()</code>","text":"<p>Convert an incremental triangle to a cumulative triangle.</p> <p>Returns:</p> Type Description <code>Triangle</code> <p>A new Triangle with cumulative values</p> Source code in <code>src\\pyre\\claims\\triangles.py</code> <pre><code>def to_cumulative(self) -&gt; 'Triangle':\n    \"\"\"\n    Convert an incremental triangle to a cumulative triangle.\n\n    Returns:\n        A new Triangle with cumulative values\n    \"\"\"\n    cumulative_triangle = {}\n\n    for oy in self.origin_years:\n        cumulative_triangle[oy] = {}\n        cumulative_value = 0.0\n\n        for dp in self.dev_periods:\n            incremental_value = self.get_value(oy, dp)\n\n            if incremental_value is None:\n                cumulative_triangle[oy][dp] = None\n            else:\n                cumulative_value += incremental_value\n                cumulative_triangle[oy][dp] = cumulative_value\n\n    return Triangle(\n        triangle=cumulative_triangle,\n        origin_years=self.origin_years.copy(),\n        dev_periods=self.dev_periods.copy()\n    )\n</code></pre>"},{"location":"claims/#pyre.claims.triangles.Triangle.to_incremental","title":"<code>to_incremental()</code>","text":"<p>Convert a cumulative triangle to an incremental triangle.</p> <p>Returns:</p> Type Description <code>Triangle</code> <p>A new Triangle with incremental values</p> Source code in <code>src\\pyre\\claims\\triangles.py</code> <pre><code>def to_incremental(self) -&gt; 'Triangle':\n    \"\"\"\n    Convert a cumulative triangle to an incremental triangle.\n\n    Returns:\n        A new Triangle with incremental values\n    \"\"\"\n    incremental_triangle = {}\n\n    for oy in self.origin_years:\n        incremental_triangle[oy] = {}\n        prev_value = None\n\n        for dp in self.dev_periods:\n            current_value = self.get_value(oy, dp)\n\n            if current_value is None:\n                incremental_triangle[oy][dp] = None\n            elif prev_value is None:\n                incremental_triangle[oy][dp] = current_value\n            else:\n                incremental_triangle[oy][dp] = current_value - prev_value\n\n            if current_value is not None:\n                prev_value = current_value\n\n    return Triangle(\n        triangle=incremental_triangle,\n        origin_years=self.origin_years.copy(),\n        dev_periods=self.dev_periods.copy()\n    )\n</code></pre>"},{"location":"exposures/","title":"Exposures Module","text":"<p>The Exposures module provides tools for managing and analyzing exposure data in reinsurance contexts. It includes classes for representing individual exposures, collections of exposures, and methods for calculating earned and written exposure values.</p>"},{"location":"exposures/#core-classes","title":"Core Classes","text":""},{"location":"exposures/#exposures-data-structure","title":"Exposures Data Structure","text":"<p>The module provides a hierarchical structure for representing exposures:</p> <ul> <li><code>ExposureBasis</code>: An enumeration defining different exposure bases (Earned, Written, etc.)</li> <li><code>ExposureMetaData</code>: Contains metadata about an exposure (ID, name, dates, currency, etc.)</li> <li><code>ExposureValues</code>: Contains financial values related to exposures (value, attachment point, limit)</li> <li><code>Exposure</code>: Combines metadata and values for a single exposure</li> <li><code>Exposures</code>: A collection of Exposure objects with methods to access and manipulate them</li> </ul>"},{"location":"exposures/#examples","title":"Examples","text":""},{"location":"exposures/#creating-and-working-with-exposures","title":"Creating and Working with Exposures","text":"<pre><code>from pyre.exposures.exposures import Exposure, Exposures, ExposureMetaData, ExposureValues, ExposureBasis\nfrom datetime import date\n\n# Create exposure metadata\nmetadata = ExposureMetaData(\n    exposure_id=\"EXP001\",\n    exposure_name=\"Property Portfolio A\",\n    exposure_period_start=date(2022, 1, 1),\n    exposure_period_end=date(2022, 12, 31),\n    currency=\"USD\",\n    aggregate=False,\n    line_of_business=\"Property\",\n    exposure_type=ExposureBasis.EARNED,\n    location=\"US East Coast\",\n    peril=\"Hurricane\"\n)\n\n# Create exposure values\nvalues = ExposureValues(\n    exposure_value=10000000,\n    attachment_point=1000000,\n    limit=5000000\n)\n\n# Create an exposure\nexposure = Exposure(metadata, values)\n\n# Access exposure properties\nprint(f\"Exposure ID: {exposure.exposure_meta.exposure_id}\")\nprint(f\"Exposure Name: {exposure.exposure_meta.exposure_name}\")\nprint(f\"Exposure Value: {exposure.exposure_values.exposure_value}\")\nprint(f\"Term Length (days): {exposure.exposure_meta.exposure_term_length_days()}\")\n\n# Calculate earned exposure as of a specific date\nanalysis_date = date(2022, 6, 30)  # Mid-year\nearned_value = exposure.earned_exposure_value(analysis_date)\nprint(f\"Earned exposure as of {analysis_date}: {earned_value}\")\n\n# Calculate written exposure\nwritten_value = exposure.written_exposure_value(analysis_date)\nprint(f\"Written exposure as of {analysis_date}: {written_value}\")\n\n# Create a collection of exposures\nexposures_collection = Exposures([exposure])\n\n# Add another exposure\nsecond_exposure = Exposure(\n    ExposureMetaData(\n        \"EXP002\", \n        \"Property Portfolio B\",\n        date(2022, 4, 1),\n        date(2023, 3, 31),\n        \"EUR\",\n        exposure_type=ExposureBasis.WRITTEN\n    ),\n    ExposureValues(5000000, 500000, 2000000)\n)\nexposures_collection.append(second_exposure)\n\n# Access exposures in the collection\nfor exp in exposures_collection:\n    print(f\"Exposure {exp.exposure_meta.exposure_id} - \"\n          f\"Period: {exp.exposure_meta.exposure_period_start} to {exp.exposure_meta.exposure_period_end}\")\n\n# Get unique modelling years\nprint(f\"Modelling years: {exposures_collection.modelling_years()}\")\n</code></pre>"},{"location":"exposures/#working-with-multiple-exposures","title":"Working with Multiple Exposures","text":"<pre><code>from pyre.exposures.exposures import Exposures\nimport pandas as pd\nfrom datetime import date\n\n# Assuming we have an Exposures collection called 'exposures_data'\n\n# Calculate total earned exposure as of a specific date\nanalysis_date = date(2022, 12, 31)\ntotal_earned = sum(exp.earned_exposure_value(analysis_date) for exp in exposures_data)\nprint(f\"Total earned exposure as of {analysis_date}: {total_earned}\")\n\n# Group exposures by line of business\nlob_exposures = {}\nfor exp in exposures_data:\n    lob = exp.exposure_meta.line_of_business\n    if lob not in lob_exposures:\n        lob_exposures[lob] = []\n    lob_exposures[lob].append(exp)\n\n# Calculate earned exposure by line of business\nfor lob, exps in lob_exposures.items():\n    lob_earned = sum(exp.earned_exposure_value(analysis_date) for exp in exps)\n    print(f\"Earned exposure for {lob}: {lob_earned}\")\n\n# Convert exposures to a pandas DataFrame for analysis\nexposure_data = []\nfor exp in exposures_data:\n    exposure_data.append({\n        'id': exp.exposure_meta.exposure_id,\n        'name': exp.exposure_meta.exposure_name,\n        'lob': exp.exposure_meta.line_of_business,\n        'start_date': exp.exposure_meta.exposure_period_start,\n        'end_date': exp.exposure_meta.exposure_period_end,\n        'value': exp.exposure_values.exposure_value,\n        'earned_value': exp.earned_exposure_value(analysis_date)\n    })\n\ndf = pd.DataFrame(exposure_data)\nprint(df.head())\n\n# Analyze exposures by various dimensions\nprint(f\"Total exposure by LOB:\\n{df.groupby('lob')['value'].sum()}\")\nprint(f\"Average exposure by LOB:\\n{df.groupby('lob')['value'].mean()}\")\n</code></pre>"},{"location":"exposures/#api-reference","title":"API Reference","text":""},{"location":"exposures/#pyre.exposures.exposures.Exposure","title":"<code>Exposure</code>","text":"<p>Represents an insurance exposure with associated metadata and values.</p> <p>This class encapsulates the metadata and values for a single exposure, providing methods to calculate earned exposure based on an analysis date.</p> <p>Attributes:</p> Name Type Description <code>_exposure_meta</code> <code>ExposureMetaData</code> <p>Metadata describing the exposure period and characteristics.</p> <code>_exposure_values</code> <code>ExposureValues</code> <p>Values associated with the exposure.</p> Properties <p>exposure_meta (ExposureMetaData): The metadata associated with this exposure. exposure_values (ExposureValues): The values associated with this exposure. modelling_year (int): The calendar year in which the exposure period starts.</p> <p>Methods:</p> Name Description <code>earned_exposure_value</code> <p>date) -&gt; float: Calculates the earned portion of the exposure value as of the given analysis date.</p> <code>written_exposure_value</code> <p>date) -&gt; float: Calculates the written exposure value as of the given analysis date.</p> Source code in <code>src\\pyre\\exposures\\exposures.py</code> <pre><code>class Exposure:\n    \"\"\"Represents an insurance exposure with associated metadata and values.\n\n    This class encapsulates the metadata and values for a single exposure, providing\n    methods to calculate earned exposure based on an analysis date.\n\n    Attributes:\n        _exposure_meta (ExposureMetaData): Metadata describing the exposure period and characteristics.\n        _exposure_values (ExposureValues): Values associated with the exposure.\n\n    Properties:\n        exposure_meta (ExposureMetaData): The metadata associated with this exposure.\n        exposure_values (ExposureValues): The values associated with this exposure.\n        modelling_year (int): The calendar year in which the exposure period starts.\n\n    Methods:\n        earned_exposure_value(analysis_date: date) -&gt; float:\n            Calculates the earned portion of the exposure value as of the given analysis date.\n        written_exposure_value(analysis_date: date) -&gt; float:\n            Calculates the written exposure value as of the given analysis date.\n    \"\"\"\n\n    def __init__(self, exposure_meta: ExposureMetaData, exposure_values: ExposureValues) -&gt; None:\n        \"\"\"Initialize an Exposure instance.\n\n        Args:\n            exposure_meta (ExposureMetaData): Metadata describing the exposure period and characteristics.\n            exposure_values (ExposureValues): Values associated with the exposure.\n        \"\"\"\n        self._exposure_meta = exposure_meta\n        self._exposure_values = exposure_values\n\n    @property\n    def exposure_meta(self) -&gt; ExposureMetaData:\n        \"\"\"Get the metadata associated with this exposure.\n\n        Returns:\n            ExposureMetaData: The metadata object.\n        \"\"\"\n        return self._exposure_meta\n\n    @property\n    def exposure_values(self) -&gt; ExposureValues:\n        \"\"\"Get the values associated with this exposure.\n\n        Returns:\n            ExposureValues: The values object.\n        \"\"\"\n        return self._exposure_values\n\n    @property\n    def modelling_year(self) -&gt; int:\n        \"\"\"Get the modelling year for this exposure.\n\n        Returns:\n            int: The calendar year in which the exposure period starts.\n        \"\"\"\n        return self._exposure_meta.exposure_period_start.year\n\n    def _earned_pct(self, analysis_date: date) -&gt; float:\n        \"\"\"Calculate the earned percentage of the exposure as of the given analysis date.\n\n        Args:\n            analysis_date (date): The date for which to calculate the earned percentage.\n\n        Returns:\n            float: The earned percentage (0.0 to 1.0). Returns 0.0 if the exposure term length is 0\n                  or if the exposure is aggregate.\n        \"\"\"\n        if self._exposure_meta.exposure_term_length_days == 0:\n            return 0.0\n        if self._exposure_meta.aggregate:  # No need for == True\n            return 0.0  # TODO: Implement parallelogram method when handling aggregate exposures\n        return min((analysis_date - self._exposure_meta.exposure_period_start).days / self._exposure_meta.exposure_term_length_days, 1.0)\n\n    def earned_exposure_value(self, analysis_date: date) -&gt; float:\n        \"\"\"Calculate the earned exposure value as of the given analysis date.\n\n        Args:\n            analysis_date (date): The date for which to calculate the earned exposure value.\n\n        Returns:\n            float: The earned exposure value. If the exposure type is EARNED, this is the full\n                  exposure value. Otherwise, it's the exposure value multiplied by the earned percentage.\n        \"\"\"\n        if self._exposure_meta.exposure_type == ExposureBasis.EARNED:\n            return self._exposure_values.exposure_value\n        else:\n            return self._exposure_values.exposure_value * self._earned_pct(analysis_date)\n\n    def written_exposure_value(self, analysis_date: date) -&gt; float:\n        \"\"\"Calculate the written exposure value as of the given analysis date.\n\n        Args:\n            analysis_date (date): The date for which to calculate the written exposure value.\n\n        Returns:\n            float: The written exposure value. If the exposure type is EARNED, this is calculated\n                  by dividing the exposure value by the earned percentage. If the earned percentage\n                  is zero, returns the exposure value directly to avoid division by zero.\n        \"\"\"\n        if self._exposure_meta.exposure_type == ExposureBasis.EARNED:\n            earned_pct = self._earned_pct(analysis_date)\n            if earned_pct &gt; 0:\n                return self._exposure_values.exposure_value / earned_pct\n            return self._exposure_values.exposure_value  # Avoid division by zero\n        else:\n            return self._exposure_values.exposure_value\n</code></pre>"},{"location":"exposures/#pyre.exposures.exposures.Exposure.exposure_meta","title":"<code>exposure_meta</code>  <code>property</code>","text":"<p>Get the metadata associated with this exposure.</p> <p>Returns:</p> Name Type Description <code>ExposureMetaData</code> <code>ExposureMetaData</code> <p>The metadata object.</p>"},{"location":"exposures/#pyre.exposures.exposures.Exposure.exposure_values","title":"<code>exposure_values</code>  <code>property</code>","text":"<p>Get the values associated with this exposure.</p> <p>Returns:</p> Name Type Description <code>ExposureValues</code> <code>ExposureValues</code> <p>The values object.</p>"},{"location":"exposures/#pyre.exposures.exposures.Exposure.modelling_year","title":"<code>modelling_year</code>  <code>property</code>","text":"<p>Get the modelling year for this exposure.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The calendar year in which the exposure period starts.</p>"},{"location":"exposures/#pyre.exposures.exposures.Exposure.__init__","title":"<code>__init__(exposure_meta, exposure_values)</code>","text":"<p>Initialize an Exposure instance.</p> <p>Parameters:</p> Name Type Description Default <code>exposure_meta</code> <code>ExposureMetaData</code> <p>Metadata describing the exposure period and characteristics.</p> required <code>exposure_values</code> <code>ExposureValues</code> <p>Values associated with the exposure.</p> required Source code in <code>src\\pyre\\exposures\\exposures.py</code> <pre><code>def __init__(self, exposure_meta: ExposureMetaData, exposure_values: ExposureValues) -&gt; None:\n    \"\"\"Initialize an Exposure instance.\n\n    Args:\n        exposure_meta (ExposureMetaData): Metadata describing the exposure period and characteristics.\n        exposure_values (ExposureValues): Values associated with the exposure.\n    \"\"\"\n    self._exposure_meta = exposure_meta\n    self._exposure_values = exposure_values\n</code></pre>"},{"location":"exposures/#pyre.exposures.exposures.Exposure.earned_exposure_value","title":"<code>earned_exposure_value(analysis_date)</code>","text":"<p>Calculate the earned exposure value as of the given analysis date.</p> <p>Parameters:</p> Name Type Description Default <code>analysis_date</code> <code>date</code> <p>The date for which to calculate the earned exposure value.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The earned exposure value. If the exposure type is EARNED, this is the full   exposure value. Otherwise, it's the exposure value multiplied by the earned percentage.</p> Source code in <code>src\\pyre\\exposures\\exposures.py</code> <pre><code>def earned_exposure_value(self, analysis_date: date) -&gt; float:\n    \"\"\"Calculate the earned exposure value as of the given analysis date.\n\n    Args:\n        analysis_date (date): The date for which to calculate the earned exposure value.\n\n    Returns:\n        float: The earned exposure value. If the exposure type is EARNED, this is the full\n              exposure value. Otherwise, it's the exposure value multiplied by the earned percentage.\n    \"\"\"\n    if self._exposure_meta.exposure_type == ExposureBasis.EARNED:\n        return self._exposure_values.exposure_value\n    else:\n        return self._exposure_values.exposure_value * self._earned_pct(analysis_date)\n</code></pre>"},{"location":"exposures/#pyre.exposures.exposures.Exposure.written_exposure_value","title":"<code>written_exposure_value(analysis_date)</code>","text":"<p>Calculate the written exposure value as of the given analysis date.</p> <p>Parameters:</p> Name Type Description Default <code>analysis_date</code> <code>date</code> <p>The date for which to calculate the written exposure value.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The written exposure value. If the exposure type is EARNED, this is calculated   by dividing the exposure value by the earned percentage. If the earned percentage   is zero, returns the exposure value directly to avoid division by zero.</p> Source code in <code>src\\pyre\\exposures\\exposures.py</code> <pre><code>def written_exposure_value(self, analysis_date: date) -&gt; float:\n    \"\"\"Calculate the written exposure value as of the given analysis date.\n\n    Args:\n        analysis_date (date): The date for which to calculate the written exposure value.\n\n    Returns:\n        float: The written exposure value. If the exposure type is EARNED, this is calculated\n              by dividing the exposure value by the earned percentage. If the earned percentage\n              is zero, returns the exposure value directly to avoid division by zero.\n    \"\"\"\n    if self._exposure_meta.exposure_type == ExposureBasis.EARNED:\n        earned_pct = self._earned_pct(analysis_date)\n        if earned_pct &gt; 0:\n            return self._exposure_values.exposure_value / earned_pct\n        return self._exposure_values.exposure_value  # Avoid division by zero\n    else:\n        return self._exposure_values.exposure_value\n</code></pre>"},{"location":"exposures/#pyre.exposures.exposures.ExposureBasis","title":"<code>ExposureBasis</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of exposure bases used in insurance calculations.</p> <p>Attributes:</p> Name Type Description <code>EARNED</code> <p>Represents exposures that have been earned over a given period.</p> <code>WRITTEN</code> <p>Represents exposures that have been written (i.e., policies issued) during a given period.</p> Source code in <code>src\\pyre\\exposures\\exposures.py</code> <pre><code>class ExposureBasis(Enum):\n    \"\"\"Enumeration of exposure bases used in insurance calculations.\n\n    Attributes:\n        EARNED: Represents exposures that have been earned over a given period.\n        WRITTEN: Represents exposures that have been written (i.e., policies issued) during a given period.\n    \"\"\"\n\n    EARNED = auto()\n    WRITTEN = auto()\n</code></pre>"},{"location":"exposures/#pyre.exposures.exposures.ExposureMetaData","title":"<code>ExposureMetaData</code>","text":"<p>Represents metadata for an insurance exposure, including identification, period, and classification details.</p> <p>Attributes:</p> Name Type Description <code>exposure_id</code> <code>str</code> <p>Unique identifier for the exposure.</p> <code>exposure_name</code> <code>str</code> <p>Human-readable name for the exposure.</p> <code>exposure_period_start</code> <code>date</code> <p>Start date of the exposure period.</p> <code>exposure_period_end</code> <code>date</code> <p>End date of the exposure period.</p> <code>currency</code> <code>str</code> <p>Currency code associated with the exposure.</p> <code>aggregate</code> <code>bool</code> <p>Indicates if the exposure is aggregated. Defaults to False.</p> <code>line_of_business</code> <code>Optional[str]</code> <p>Line of business associated with the exposure.</p> <code>stacking_id</code> <code>Optional[str]</code> <p>Identifier for stacking exposures.</p> <code>exposure_type</code> <code>Optional[ExposureBasis]</code> <p>Type or basis of the exposure. Defaults to ExposureBasis.EARNED.</p> <code>location</code> <code>Optional[str]</code> <p>Location associated with the exposure.</p> <code>peril</code> <code>Optional[str]</code> <p>Peril associated with the exposure.</p> <code>occupancy</code> <code>Optional[str]</code> <p>Occupancy type for the exposure.</p> Properties <p>exposure_term_length_days (int): Number of days in the exposure period.</p> Source code in <code>src\\pyre\\exposures\\exposures.py</code> <pre><code>class ExposureMetaData:\n    \"\"\"Represents metadata for an insurance exposure, including identification, period, and classification details.\n\n    Attributes:\n        exposure_id (str): Unique identifier for the exposure.\n        exposure_name (str): Human-readable name for the exposure.\n        exposure_period_start (date): Start date of the exposure period.\n        exposure_period_end (date): End date of the exposure period.\n        currency (str): Currency code associated with the exposure.\n        aggregate (bool): Indicates if the exposure is aggregated. Defaults to False.\n        line_of_business (Optional[str]): Line of business associated with the exposure.\n        stacking_id (Optional[str]): Identifier for stacking exposures.\n        exposure_type (Optional[ExposureBasis]): Type or basis of the exposure. Defaults to ExposureBasis.EARNED.\n        location (Optional[str]): Location associated with the exposure.\n        peril (Optional[str]): Peril associated with the exposure.\n        occupancy (Optional[str]): Occupancy type for the exposure.\n\n    Properties:\n        exposure_term_length_days (int): Number of days in the exposure period.\n    \"\"\"\n    def __init__(\n        self,\n        exposure_id: str,\n        exposure_name: str,\n        exposure_period_start: date,\n        exposure_period_end: date,\n        currency: str,\n        aggregate: bool = False,\n        line_of_business: Optional[str] = None,\n        stacking_id: Optional[str] = None,\n        exposure_type: Optional[ExposureBasis] = ExposureBasis.EARNED,\n        location: Optional[str] = None,\n        peril: Optional[str] = None,\n        occupancy: Optional[str] = None\n    ):\n        \"\"\"Initialize an ExposureMetaData instance.\n\n        Args:\n            exposure_id (str): Unique identifier for the exposure.\n            exposure_name (str): Human-readable name for the exposure.\n            exposure_period_start (date): Start date of the exposure period.\n            exposure_period_end (date): End date of the exposure period.\n            currency (str): Currency code associated with the exposure.\n            aggregate (bool, optional): Indicates if the exposure is aggregated. Defaults to False.\n            line_of_business (Optional[str], optional): Line of business. Defaults to None.\n            stacking_id (Optional[str], optional): Identifier for stacking exposures. Defaults to None.\n            exposure_type (Optional[ExposureBasis], optional): Type of exposure. Defaults to ExposureBasis.EARNED.\n            location (Optional[str], optional): Location associated with the exposure. Defaults to None.\n            peril (Optional[str], optional): Peril associated with the exposure. Defaults to None.\n            occupancy (Optional[str], optional): Occupancy type for the exposure. Defaults to None.\n\n        Raises:\n            ValueError: If exposure_period_end is before exposure_period_start.\n        \"\"\"\n        if exposure_period_end &lt; exposure_period_start:\n            raise ValueError(\"Exposure period end date cannot be before start date\")\n\n        self._exposure_id = exposure_id\n        self._exposure_name = exposure_name\n        self._exposure_period_start = exposure_period_start\n        self._exposure_period_end = exposure_period_end\n        self._currency = currency\n        self._aggregate = aggregate\n        self._line_of_business = line_of_business\n        self._stacking_id = stacking_id\n        self._exposure_type = exposure_type\n        self._location = location\n        self._peril = peril\n        self._occupancy = occupancy\n\n    @property\n    def exposure_id(self) -&gt; str:\n        return self._exposure_id\n\n    @exposure_id.setter\n    def exposure_id(self, value: str) -&gt; None:\n        self._exposure_id = value\n\n    @property\n    def exposure_name(self) -&gt; str:\n        return self._exposure_name\n\n    @exposure_name.setter\n    def exposure_name(self, value: str) -&gt; None:\n        self._exposure_name = value\n\n    @property\n    def exposure_period_start(self) -&gt; date:\n        return self._exposure_period_start\n\n    @exposure_period_start.setter\n    def exposure_period_start(self, value: date) -&gt; None:\n        \"\"\"Set the exposure period start date.\n\n        Args:\n            value (date): The new start date.\n\n        Raises:\n            ValueError: If the new start date is after the current end date.\n        \"\"\"\n        if hasattr(self, '_exposure_period_end') and value &gt; self._exposure_period_end:\n            raise ValueError(\"Exposure period start date cannot be after end date\")\n        self._exposure_period_start = value\n\n    @property\n    def exposure_period_end(self) -&gt; date:\n        return self._exposure_period_end\n\n    @exposure_period_end.setter\n    def exposure_period_end(self, value: date) -&gt; None:\n        \"\"\"Set the exposure period end date.\n\n        Args:\n            value (date): The new end date.\n\n        Raises:\n            ValueError: If the new end date is before the current start date.\n        \"\"\"\n        if hasattr(self, '_exposure_period_start') and value &lt; self._exposure_period_start:\n            raise ValueError(\"Exposure period end date cannot be before start date\")\n        self._exposure_period_end = value\n\n    @property\n    def currency(self) -&gt; str:\n        return self._currency\n\n    @currency.setter\n    def currency(self, value: str) -&gt; None:\n        self._currency = value\n\n    @property\n    def aggregate(self) -&gt; bool:\n        return self._aggregate\n\n    @aggregate.setter\n    def aggregate(self, value: bool) -&gt; None:\n        self._aggregate = value\n\n    @property\n    def line_of_business(self) -&gt; Optional[str]:\n        return self._line_of_business\n\n    @line_of_business.setter\n    def line_of_business(self, value: Optional[str]) -&gt; None:\n        self._line_of_business = value\n\n    @property\n    def stacking_id(self) -&gt; Optional[str]:\n        return self._stacking_id\n\n    @stacking_id.setter\n    def stacking_id(self, value: Optional[str]) -&gt; None:\n        self._stacking_id = value\n\n    @property\n    def exposure_type(self) -&gt; ExposureBasis:\n        return self._exposure_type\n\n    @exposure_type.setter\n    def exposure_type(self, value: ExposureBasis) -&gt; None:\n        self._exposure_type = value\n\n    @property\n    def location(self) -&gt; Optional[str]:\n        return self._location\n\n    @location.setter\n    def location(self, value: Optional[str]) -&gt; None:\n        self._location = value\n\n    @property\n    def peril(self) -&gt; Optional[str]:\n        return self._peril\n\n    @peril.setter\n    def peril(self, value: Optional[str]) -&gt; None:\n        self._peril = value\n\n    @property\n    def occupancy(self) -&gt; Optional[str]:\n        return self._occupancy\n\n    @occupancy.setter\n    def occupancy(self, value: Optional[str]) -&gt; None:\n        self._occupancy = value\n    @property\n    def exposure_term_length_days(self) -&gt; int:\n        return (self.exposure_period_end - self.exposure_period_start).days\n</code></pre>"},{"location":"exposures/#pyre.exposures.exposures.ExposureMetaData.__init__","title":"<code>__init__(exposure_id, exposure_name, exposure_period_start, exposure_period_end, currency, aggregate=False, line_of_business=None, stacking_id=None, exposure_type=ExposureBasis.EARNED, location=None, peril=None, occupancy=None)</code>","text":"<p>Initialize an ExposureMetaData instance.</p> <p>Parameters:</p> Name Type Description Default <code>exposure_id</code> <code>str</code> <p>Unique identifier for the exposure.</p> required <code>exposure_name</code> <code>str</code> <p>Human-readable name for the exposure.</p> required <code>exposure_period_start</code> <code>date</code> <p>Start date of the exposure period.</p> required <code>exposure_period_end</code> <code>date</code> <p>End date of the exposure period.</p> required <code>currency</code> <code>str</code> <p>Currency code associated with the exposure.</p> required <code>aggregate</code> <code>bool</code> <p>Indicates if the exposure is aggregated. Defaults to False.</p> <code>False</code> <code>line_of_business</code> <code>Optional[str]</code> <p>Line of business. Defaults to None.</p> <code>None</code> <code>stacking_id</code> <code>Optional[str]</code> <p>Identifier for stacking exposures. Defaults to None.</p> <code>None</code> <code>exposure_type</code> <code>Optional[ExposureBasis]</code> <p>Type of exposure. Defaults to ExposureBasis.EARNED.</p> <code>EARNED</code> <code>location</code> <code>Optional[str]</code> <p>Location associated with the exposure. Defaults to None.</p> <code>None</code> <code>peril</code> <code>Optional[str]</code> <p>Peril associated with the exposure. Defaults to None.</p> <code>None</code> <code>occupancy</code> <code>Optional[str]</code> <p>Occupancy type for the exposure. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If exposure_period_end is before exposure_period_start.</p> Source code in <code>src\\pyre\\exposures\\exposures.py</code> <pre><code>def __init__(\n    self,\n    exposure_id: str,\n    exposure_name: str,\n    exposure_period_start: date,\n    exposure_period_end: date,\n    currency: str,\n    aggregate: bool = False,\n    line_of_business: Optional[str] = None,\n    stacking_id: Optional[str] = None,\n    exposure_type: Optional[ExposureBasis] = ExposureBasis.EARNED,\n    location: Optional[str] = None,\n    peril: Optional[str] = None,\n    occupancy: Optional[str] = None\n):\n    \"\"\"Initialize an ExposureMetaData instance.\n\n    Args:\n        exposure_id (str): Unique identifier for the exposure.\n        exposure_name (str): Human-readable name for the exposure.\n        exposure_period_start (date): Start date of the exposure period.\n        exposure_period_end (date): End date of the exposure period.\n        currency (str): Currency code associated with the exposure.\n        aggregate (bool, optional): Indicates if the exposure is aggregated. Defaults to False.\n        line_of_business (Optional[str], optional): Line of business. Defaults to None.\n        stacking_id (Optional[str], optional): Identifier for stacking exposures. Defaults to None.\n        exposure_type (Optional[ExposureBasis], optional): Type of exposure. Defaults to ExposureBasis.EARNED.\n        location (Optional[str], optional): Location associated with the exposure. Defaults to None.\n        peril (Optional[str], optional): Peril associated with the exposure. Defaults to None.\n        occupancy (Optional[str], optional): Occupancy type for the exposure. Defaults to None.\n\n    Raises:\n        ValueError: If exposure_period_end is before exposure_period_start.\n    \"\"\"\n    if exposure_period_end &lt; exposure_period_start:\n        raise ValueError(\"Exposure period end date cannot be before start date\")\n\n    self._exposure_id = exposure_id\n    self._exposure_name = exposure_name\n    self._exposure_period_start = exposure_period_start\n    self._exposure_period_end = exposure_period_end\n    self._currency = currency\n    self._aggregate = aggregate\n    self._line_of_business = line_of_business\n    self._stacking_id = stacking_id\n    self._exposure_type = exposure_type\n    self._location = location\n    self._peril = peril\n    self._occupancy = occupancy\n</code></pre>"},{"location":"exposures/#pyre.exposures.exposures.ExposureValues","title":"<code>ExposureValues</code>","text":"<p>Represents the key financial values associated with an insurance exposure.</p> <p>Attributes:</p> Name Type Description <code>exposure_value</code> <code>float</code> <p>The total value of the exposure, such as the insured amount.</p> <code>attachment_point</code> <code>float</code> <p>The threshold amount at which coverage begins to apply.</p> <code>limit</code> <code>float</code> <p>The maximum amount payable under the coverage.</p> Source code in <code>src\\pyre\\exposures\\exposures.py</code> <pre><code>class ExposureValues:\n    \"\"\"Represents the key financial values associated with an insurance exposure.\n\n    Attributes:\n        exposure_value (float): The total value of the exposure, such as the insured amount.\n        attachment_point (float): The threshold amount at which coverage begins to apply.\n        limit (float): The maximum amount payable under the coverage.\n    \"\"\"\n    def __init__(self, exposure_value: float, attachment_point: float, limit: float):\n        \"\"\"Initialize an ExposureValues instance.\n\n        Args:\n            exposure_value (float): The total value of the exposure.\n            attachment_point (float): The threshold amount at which coverage begins to apply.\n            limit (float): The maximum amount payable under the coverage.\n\n        Raises:\n            ValueError: If attachment_point or limit is negative.\n        \"\"\"\n        if attachment_point &lt; 0:\n            raise ValueError(\"Attachment point cannot be negative\")\n        if limit &lt; 0:\n            raise ValueError(\"Limit cannot be negative\")\n\n        self._exposure_value = exposure_value\n        self._attachment_point = attachment_point\n        self._limit = limit\n\n    @property\n    def exposure_value(self) -&gt; float:\n        return self._exposure_value\n\n    @exposure_value.setter\n    def exposure_value(self, value: float) -&gt; None:\n        self._exposure_value = value\n\n    @property\n    def attachment_point(self) -&gt; float:\n        return self._attachment_point\n\n    @attachment_point.setter\n    def attachment_point(self, value: float) -&gt; None:\n        \"\"\"Set the attachment point.\n\n        Args:\n            value (float): The new attachment point.\n\n        Raises:\n            ValueError: If the new attachment point is negative.\n        \"\"\"\n        if value &lt; 0:\n            raise ValueError(\"Attachment point cannot be negative\")\n        self._attachment_point = value\n\n    @property\n    def limit(self) -&gt; float:\n        return self._limit\n\n    @limit.setter\n    def limit(self, value: float) -&gt; None:\n        \"\"\"Set the limit.\n\n        Args:\n            value (float): The new limit.\n\n        Raises:\n            ValueError: If the new limit is negative.\n        \"\"\"\n        if value &lt; 0:\n            raise ValueError(\"Limit cannot be negative\")\n        self._limit = value\n</code></pre>"},{"location":"exposures/#pyre.exposures.exposures.ExposureValues.__init__","title":"<code>__init__(exposure_value, attachment_point, limit)</code>","text":"<p>Initialize an ExposureValues instance.</p> <p>Parameters:</p> Name Type Description Default <code>exposure_value</code> <code>float</code> <p>The total value of the exposure.</p> required <code>attachment_point</code> <code>float</code> <p>The threshold amount at which coverage begins to apply.</p> required <code>limit</code> <code>float</code> <p>The maximum amount payable under the coverage.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If attachment_point or limit is negative.</p> Source code in <code>src\\pyre\\exposures\\exposures.py</code> <pre><code>def __init__(self, exposure_value: float, attachment_point: float, limit: float):\n    \"\"\"Initialize an ExposureValues instance.\n\n    Args:\n        exposure_value (float): The total value of the exposure.\n        attachment_point (float): The threshold amount at which coverage begins to apply.\n        limit (float): The maximum amount payable under the coverage.\n\n    Raises:\n        ValueError: If attachment_point or limit is negative.\n    \"\"\"\n    if attachment_point &lt; 0:\n        raise ValueError(\"Attachment point cannot be negative\")\n    if limit &lt; 0:\n        raise ValueError(\"Limit cannot be negative\")\n\n    self._exposure_value = exposure_value\n    self._attachment_point = attachment_point\n    self._limit = limit\n</code></pre>"},{"location":"exposures/#pyre.exposures.exposures.Exposures","title":"<code>Exposures</code>","text":"<p>A container class for managing a collection of Exposure objects.</p> <p>This class provides list-like behavior for storing and manipulating multiple Exposure instances. It supports indexing, slicing, iteration, and appending new exposures.</p> <p>Attributes:</p> Name Type Description <code>exposures</code> <code>List[Exposure]</code> <p>The list of Exposure objects managed by this container.</p> <p>Parameters:</p> Name Type Description Default <code>exposures</code> <code>List[Exposure]</code> <p>A list of Exposure objects to initialize the container.</p> required <p>Methods:</p> Name Description <code>append</code> <p>Exposure): Appends an Exposure object to the collection.</p> <code>__getitem__</code> <p>Returns an Exposure or a new Exposures instance for slices.</p> <code>__iter__</code> <p>Returns an iterator over the exposures.</p> <code>__len__</code> <p>Returns the number of exposures in the collection.</p> Source code in <code>src\\pyre\\exposures\\exposures.py</code> <pre><code>class Exposures:\n    \"\"\"A container class for managing a collection of Exposure objects.\n\n    This class provides list-like behavior for storing and manipulating multiple\n    Exposure instances. It supports indexing, slicing, iteration, and appending\n    new exposures.\n\n    Attributes:\n        exposures (List[Exposure]): The list of Exposure objects managed by this container.\n\n    Args:\n        exposures (List[Exposure]): A list of Exposure objects to initialize the container.\n\n    Methods:\n        append(exposure: Exposure): Appends an Exposure object to the collection.\n        __getitem__(key): Returns an Exposure or a new Exposures instance for slices.\n        __iter__(): Returns an iterator over the exposures.\n        __len__(): Returns the number of exposures in the collection.\n    \"\"\"\n\n    def __init__(self, exposures: List[Exposure])-&gt;None:\n        self._exposures = exposures\n\n    @property\n    def exposures(self) -&gt; List[Exposure]:\n        \"\"\"Returns the list of Exposure objects managed by this container.\"\"\"\n        return self._exposures\n\n    @exposures.setter\n    def exposures(self, list_of_exposure_classes: List[Exposure]) -&gt; None:\n        \"\"\"Sets the list of Exposure objects managed by this container.\"\"\"\n        self._exposures = list_of_exposure_classes\n\n    @property\n    def modelling_years(self) -&gt; List[int]: \n        \"\"\"\n        Returns a sorted list of unique modelling years for all exposures.\n\n        Returns:\n            List[int]: A sorted list of unique modelling years.\n        \"\"\"\n        years = {exposure.modelling_year for exposure in self.exposures}\n        return sorted(years)\n\n    def append(self, exposure: Exposure) -&gt; None:\n        \"\"\"Append an Exposure object to the collection.\n\n        Args:\n            exposure (Exposure): The Exposure object to append.\n        \"\"\"\n        self._exposures.append(exposure)\n\n    def __getitem__(self, key):\n        \"\"\"Get an Exposure object by index or a slice of Exposures.\n\n        Args:\n            key: An integer index or a slice object.\n\n        Returns:\n            Union[Exposure, 'Exposures']: An Exposure object if key is an integer,\n                                         or a new Exposures instance if key is a slice.\n        \"\"\"\n        if isinstance(key, slice):\n            cls = type(self)\n            return cls(self._exposures[key])\n        index = operator.index(key)\n        return self._exposures[index]\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the exposures.\n\n        Returns:\n            Iterator[Exposure]: An iterator over the Exposure objects.\n        \"\"\"\n        return iter(self._exposures)\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of exposures in the collection.\n\n        Returns:\n            int: The number of Exposure objects.\n        \"\"\"\n        return len(self._exposures)\n</code></pre>"},{"location":"exposures/#pyre.exposures.exposures.Exposures.exposures","title":"<code>exposures</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the list of Exposure objects managed by this container.</p>"},{"location":"exposures/#pyre.exposures.exposures.Exposures.modelling_years","title":"<code>modelling_years</code>  <code>property</code>","text":"<p>Returns a sorted list of unique modelling years for all exposures.</p> <p>Returns:</p> Type Description <code>List[int]</code> <p>List[int]: A sorted list of unique modelling years.</p>"},{"location":"exposures/#pyre.exposures.exposures.Exposures.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Get an Exposure object by index or a slice of Exposures.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <p>An integer index or a slice object.</p> required <p>Returns:</p> Type Description <p>Union[Exposure, 'Exposures']: An Exposure object if key is an integer,                          or a new Exposures instance if key is a slice.</p> Source code in <code>src\\pyre\\exposures\\exposures.py</code> <pre><code>def __getitem__(self, key):\n    \"\"\"Get an Exposure object by index or a slice of Exposures.\n\n    Args:\n        key: An integer index or a slice object.\n\n    Returns:\n        Union[Exposure, 'Exposures']: An Exposure object if key is an integer,\n                                     or a new Exposures instance if key is a slice.\n    \"\"\"\n    if isinstance(key, slice):\n        cls = type(self)\n        return cls(self._exposures[key])\n    index = operator.index(key)\n    return self._exposures[index]\n</code></pre>"},{"location":"exposures/#pyre.exposures.exposures.Exposures.__iter__","title":"<code>__iter__()</code>","text":"<p>Return an iterator over the exposures.</p> <p>Returns:</p> Type Description <p>Iterator[Exposure]: An iterator over the Exposure objects.</p> Source code in <code>src\\pyre\\exposures\\exposures.py</code> <pre><code>def __iter__(self):\n    \"\"\"Return an iterator over the exposures.\n\n    Returns:\n        Iterator[Exposure]: An iterator over the Exposure objects.\n    \"\"\"\n    return iter(self._exposures)\n</code></pre>"},{"location":"exposures/#pyre.exposures.exposures.Exposures.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of exposures in the collection.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of Exposure objects.</p> Source code in <code>src\\pyre\\exposures\\exposures.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of exposures in the collection.\n\n    Returns:\n        int: The number of Exposure objects.\n    \"\"\"\n    return len(self._exposures)\n</code></pre>"},{"location":"exposures/#pyre.exposures.exposures.Exposures.append","title":"<code>append(exposure)</code>","text":"<p>Append an Exposure object to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>exposure</code> <code>Exposure</code> <p>The Exposure object to append.</p> required Source code in <code>src\\pyre\\exposures\\exposures.py</code> <pre><code>def append(self, exposure: Exposure) -&gt; None:\n    \"\"\"Append an Exposure object to the collection.\n\n    Args:\n        exposure (Exposure): The Exposure object to append.\n    \"\"\"\n    self._exposures.append(exposure)\n</code></pre>"},{"location":"models/","title":"Models Module","text":"<p>The Models module provides a variety of actuarial and statistical modeling tools for reinsurance pricing. It includes submodules for experience rating, exposure rating, and aggregate features modeling.</p>"},{"location":"models/#submodules","title":"Submodules","text":""},{"location":"models/#experience-rating","title":"Experience Rating","text":"<p>The Experience module provides tools for analyzing historical claims experience:</p> <ul> <li><code>burn_cost</code>: Methods for burn cost analysis</li> <li><code>curve_fitting</code>: Functions for fitting curves to data</li> <li><code>frequency_severity</code>: Tools for frequency-severity modeling</li> <li><code>pareto_rating</code>: Pareto distribution-based rating methods</li> <li><code>resampling</code>: Methods for resampling claims data</li> </ul>"},{"location":"models/#exposure-rating","title":"Exposure Rating","text":"<p>The Exposure module provides tools for exposure-based rating:</p> <ul> <li><code>mbbefd</code>: Implementation of the Modified Beta Beta Equivalent Finite Difference (MBBEFD) distribution</li> <li><code>mixed_exponential</code>: Implementation of the Mixed Exponential distribution</li> <li><code>pareto_ilf</code>: Pareto distribution-based Increased Limit Factors</li> <li><code>riebesell</code>: Implementation of the Riebesell approximation</li> </ul>"},{"location":"models/#aggregate-features","title":"Aggregate Features","text":"<p>The AggregateFeatures module provides tools for modeling aggregate loss distributions:</p> <ul> <li><code>aggregate_features</code>: Methods for calculating aggregate loss statistics</li> <li><code>selections</code>: Tools for selecting and combining models</li> <li><code>simulation_engine</code>: Monte Carlo simulation engine for aggregate losses</li> </ul>"},{"location":"models/#trending","title":"Trending","text":"<p>The trending module provides tools for trending historical data to current levels.</p>"},{"location":"models/#examples","title":"Examples","text":""},{"location":"models/#experience-rating_1","title":"Experience Rating","text":""},{"location":"models/#burn-cost-analysis","title":"Burn Cost Analysis","text":"<pre><code>from pyre.Models.Experience.burn_cost import BurnCostModel\nfrom pyre.claims.claims import Claims\nimport numpy as np\n\n# Assuming we have a Claims collection called 'claims_data'\n\n# Create a burn cost model\nmodel = BurnCostModel(claims_data)\n\n# Calculate basic burn cost statistics\nburn_cost = model.calculate_burn_cost()\nprint(f\"Average burn cost: {burn_cost}\")\n\n# Calculate burn cost with trend\ntrend_factor = 1.05  # 5% annual trend\nyears_of_trend = 2\ntrended_burn_cost = model.calculate_trended_burn_cost(trend_factor, years_of_trend)\nprint(f\"Trended burn cost: {trended_burn_cost}\")\n\n# Calculate burn cost with limits\nattachment = 1000000\nlimit = 5000000\nlimited_burn_cost = model.calculate_limited_burn_cost(attachment, limit)\nprint(f\"Limited burn cost: {limited_burn_cost}\")\n\n# Calculate confidence intervals\nconfidence_level = 0.95\nlower, upper = model.calculate_confidence_interval(confidence_level)\nprint(f\"{confidence_level*100}% confidence interval: ({lower}, {upper})\")\n</code></pre>"},{"location":"models/#frequency-severity-modeling","title":"Frequency-Severity Modeling","text":"<pre><code>from pyre.Models.Experience.frequency_severity import FrequencySeverityModel\nfrom pyre.claims.claims import Claims\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Assuming we have a Claims collection called 'claims_data'\n\n# Create a frequency-severity model\nmodel = FrequencySeverityModel(claims_data)\n\n# Fit frequency distribution (Poisson)\nfreq_params = model.fit_frequency_distribution(\"poisson\")\nprint(f\"Frequency distribution parameters: {freq_params}\")\n\n# Fit severity distribution (Lognormal)\nsev_params = model.fit_severity_distribution(\"lognormal\")\nprint(f\"Severity distribution parameters: {sev_params}\")\n\n# Simulate aggregate losses\nnum_simulations = 10000\naggregate_losses = model.simulate_aggregate_losses(num_simulations)\n\n# Calculate statistics\nmean_loss = np.mean(aggregate_losses)\nmedian_loss = np.median(aggregate_losses)\nvar_95 = np.percentile(aggregate_losses, 95)\nvar_99 = np.percentile(aggregate_losses, 99)\n\nprint(f\"Mean aggregate loss: {mean_loss}\")\nprint(f\"Median aggregate loss: {median_loss}\")\nprint(f\"95% VaR: {var_95}\")\nprint(f\"99% VaR: {var_99}\")\n\n# Plot histogram of aggregate losses\nplt.figure(figsize=(10, 6))\nplt.hist(aggregate_losses, bins=50, alpha=0.7)\nplt.axvline(mean_loss, color='r', linestyle='--', label=f'Mean: {mean_loss:.2f}')\nplt.axvline(var_95, color='g', linestyle='--', label=f'95% VaR: {var_95:.2f}')\nplt.axvline(var_99, color='b', linestyle='--', label=f'99% VaR: {var_99:.2f}')\nplt.legend()\nplt.title('Simulated Aggregate Loss Distribution')\nplt.xlabel('Aggregate Loss')\nplt.ylabel('Frequency')\nplt.show()\n</code></pre>"},{"location":"models/#exposure-rating_1","title":"Exposure Rating","text":""},{"location":"models/#increased-limit-factors","title":"Increased Limit Factors","text":"<pre><code>from pyre.Models.Exposure.pareto_ilf import ParetoILF\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Create a Pareto ILF model\nalpha = 2.0  # Pareto shape parameter\nmodel = ParetoILF(alpha)\n\n# Calculate increased limit factors\nbase_limit = 1000000\nlimits = [1000000, 2000000, 5000000, 10000000, 25000000]\nilfs = [model.calculate_ilf(base_limit, limit) for limit in limits]\n\nprint(\"Increased Limit Factors:\")\nfor limit, ilf in zip(limits, ilfs):\n    print(f\"  {limit/1000000}M: {ilf:.4f}\")\n\n# Calculate layer costs\nattachment = 5000000\nlimit = 5000000\nlayer_cost = model.calculate_layer_cost(attachment, attachment + limit)\nprint(f\"Layer cost for {attachment/1000000}M xs {limit/1000000}M: {layer_cost:.4f}\")\n\n# Plot ILF curve\nlimits_plot = np.linspace(base_limit, 25000000, 100)\nilfs_plot = [model.calculate_ilf(base_limit, limit) for limit in limits_plot]\n\nplt.figure(figsize=(10, 6))\nplt.plot(limits_plot/1000000, ilfs_plot)\nplt.scatter([l/1000000 for l in limits], ilfs, color='red', s=50)\nplt.title('Pareto Increased Limit Factors')\nplt.xlabel('Limit (Millions)')\nplt.ylabel('ILF')\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"models/#trending_1","title":"Trending","text":"<pre><code>from pyre.Models.trending import apply_trend, compound_trend\nimport numpy as np\nimport pandas as pd\n\n# Create sample data\nyears = [2018, 2019, 2020, 2021, 2022]\nvalues = [100, 110, 125, 135, 150]\n\n# Apply trend to project future values\nannual_trend = 0.08  # 8% annual trend\nprojected_years = [2023, 2024, 2025]\nprojected_values = apply_trend(values[-1], annual_trend, len(projected_years))\n\nall_years = years + projected_years\nall_values = values + projected_values\n\nprint(\"Historical and Projected Values:\")\nfor year, value in zip(all_years, all_values):\n    print(f\"  {year}: {value:.2f}\")\n\n# Calculate compound trend between two periods\nstart_value = values[0]\nend_value = values[-1]\nnum_periods = len(years) - 1\nimplied_trend = compound_trend(start_value, end_value, num_periods)\nprint(f\"Implied annual trend: {implied_trend:.2%}\")\n\n# Create a DataFrame for analysis\ndf = pd.DataFrame({\n    'Year': all_years,\n    'Value': all_values\n})\n\n# Calculate year-over-year trends\ndf['YoY_Trend'] = df['Value'].pct_change()\n\nprint(\"\\nYear-over-Year Trends:\")\nprint(df[['Year', 'Value', 'YoY_Trend']])\n</code></pre>"},{"location":"models/#api-reference","title":"API Reference","text":""},{"location":"models/#pyre.Models.Experience.burn_cost.BurnCostModel","title":"<code>BurnCostModel</code>","text":"<p>BurnCostModel is a class that calculates burn costs for a reinsurance contract layer.</p> <p>It uses various projection methods to estimate ultimate claims and calculate burn costs based on historical claims and exposures data.</p> <p>Attributes:</p> Name Type Description <code>_modelling_years</code> <code>List[int]</code> <p>The years to be used in the modelling.</p> <code>_years_weighting</code> <code>Dict[int, float]</code> <p>Weighting factors for each modelling year.</p> <code>_projection_methods</code> <code>Dict[int, ProjectionMethods]</code> <p>Projection method to use for each modelling year.</p> <code>_development_pattern</code> <code>Dict[int, float]</code> <p>Development factors for each modelling year.</p> <code>_a_priori</code> <code>Dict[int, float]</code> <p>A priori expected loss ratios for each modelling year.</p> <code>_data</code> <code>ExperienceModelData</code> <p>The claims and exposures data for the reinsurance contract.</p> <code>_layer_id</code> <code>Any</code> <p>The identifier for the reinsurance contract layer.</p> Source code in <code>src\\pyre\\Models\\Experience\\burn_cost.py</code> <pre><code>class BurnCostModel:\n    \"\"\"\n    BurnCostModel is a class that calculates burn costs for a reinsurance contract layer.\n\n    It uses various projection methods to estimate ultimate claims and calculate burn costs\n    based on historical claims and exposures data.\n\n    Attributes:\n        _modelling_years (List[int]): The years to be used in the modelling.\n        _years_weighting (Dict[int, float]): Weighting factors for each modelling year.\n        _projection_methods (Dict[int, ProjectionMethods]): Projection method to use for each modelling year.\n        _development_pattern (Dict[int, float]): Development factors for each modelling year.\n        _a_priori (Dict[int, float]): A priori expected loss ratios for each modelling year.\n        _data (ExperienceModelData): The claims and exposures data for the reinsurance contract.\n        _layer_id (Any): The identifier for the reinsurance contract layer.\n    \"\"\"\n    def __init__(self,\n                model_data: ExperienceModelData, \n                layer_id: Any, \n                years_weighting: Optional[Dict[int, float]] = None, \n                projection_methods: Optional[Dict[int, ProjectionMethods]] = None,\n                development_pattern: Optional[Dict[int, float]] = None,\n                a_priori_assumption: Optional[Dict[int, float]] = None) -&gt; None:\n        \"\"\"\n        Initialize a BurnCostModel instance.\n\n        Args:\n            model_data (ExperienceModelData): The claims and exposures data for the reinsurance contract.\n            layer_id (Any): The identifier for the reinsurance contract layer.\n            years_weighting (Optional[Dict[int, float]], optional): Weighting factors for each modelling year.\n                If None, equal weights of 1.0 will be used for all years. Defaults to None.\n            projection_methods (Optional[Dict[int, ProjectionMethods]], optional): Projection method to use for each modelling year.\n                If None, SIMPLE_CAPE_COD will be used for all years. Defaults to None.\n            development_pattern (Optional[Dict[int, float]], optional): Development factors for each modelling year.\n                If None, factors of 1.0 will be used for all years (no development). Defaults to None.\n            a_priori_assumption (Optional[Dict[int, float]], optional): A priori expected loss ratios for each modelling year.\n                If None, values of 0.0 will be used for all years (no a priori assumption). Defaults to None.\n        \"\"\"\n        self._modelling_years = model_data.exposures.modelling_years\n        self._years_weighting = years_weighting if years_weighting else {year: 1.0 for year in model_data.exposures.modelling_years}\n        self._projection_methods = projection_methods if projection_methods else {year: ProjectionMethods.SIMPLE_CAPE_COD for year in model_data.exposures.modelling_years}  # Default to simple cape cod method\n        self._development_pattern = development_pattern if development_pattern else {year: 1.0 for year in model_data.exposures.modelling_years}  # Default to no development pattern\n        self._a_priori = a_priori_assumption if a_priori_assumption else {year: 0.0 for year in model_data.exposures.modelling_years}  # Default to no a priori assumption\n        self._data = model_data\n        self._layer_id = layer_id\n\n    @property\n    def modelling_years(self) -&gt; List[int]:\n        \"\"\"\n        Get the years to be used in the modelling.\n\n        Returns:\n            List[int]: The modelling years.\n        \"\"\"\n        return self._modelling_years\n\n    @modelling_years.setter\n    def modelling_years(self, years: List[int]) -&gt; None:\n        \"\"\"\n        Set the years to be used in the modelling.\n\n        Args:\n            years (List[int]): The new modelling years.\n        \"\"\"\n        self._modelling_years = years\n\n    @property\n    def years_weighting(self) -&gt; Dict[int, float]:\n        \"\"\"\n        Get the weighting factors for each modelling year.\n\n        Returns:\n            Dict[int, float]: Mapping of modelling year to weighting factor.\n        \"\"\"\n        return self._years_weighting\n\n    @years_weighting.setter\n    def years_weighting(self, weighting: Dict[int, float]) -&gt; None:\n        \"\"\"\n        Set the weighting factors for each modelling year.\n\n        Args:\n            weighting (Dict[int, float]): Mapping of modelling year to weighting factor.\n        \"\"\"\n        self._years_weighting = weighting\n\n    @property\n    def projection_methods(self) -&gt; Dict[int, ProjectionMethods]:\n        \"\"\"\n        Get the projection method to use for each modelling year.\n\n        Returns:\n            Dict[int, ProjectionMethods]: Mapping of modelling year to projection method.\n        \"\"\"\n        return self._projection_methods\n\n    @projection_methods.setter\n    def projection_methods(self, methods: Dict[int, ProjectionMethods]) -&gt; None:\n        \"\"\"\n        Set the projection method to use for each modelling year.\n\n        Args:\n            methods (Dict[int, ProjectionMethods]): Mapping of modelling year to projection method.\n        \"\"\"\n        self._projection_methods = methods\n\n    @property\n    def development_pattern(self) -&gt; Dict[int, float]:\n        \"\"\"\n        Get the development factors for each modelling year.\n\n        Returns:\n            Dict[int, float]: Mapping of modelling year to development factor.\n        \"\"\"\n        return self._development_pattern\n\n    @development_pattern.setter\n    def development_pattern(self, pattern: Dict[int, float]) -&gt; None:\n        \"\"\"\n        Set the development factors for each modelling year.\n\n        Args:\n            pattern (Dict[int, float]): Mapping of modelling year to development factor.\n        \"\"\"\n        self._development_pattern = pattern\n\n    @property\n    def data(self) -&gt; ExperienceModelData:\n        \"\"\"\n        Get the claims and exposures data for the reinsurance contract.\n\n        Returns:\n            ExperienceModelData: The claims and exposures data.\n        \"\"\"\n        return self._data\n\n    @data.setter\n    def data(self, model_data: ExperienceModelData) -&gt; None:\n        \"\"\"\n        Set the claims and exposures data for the reinsurance contract.\n\n        Args:\n            model_data (ExperienceModelData): The new claims and exposures data.\n        \"\"\"\n        self._data = model_data\n\n    @property\n    def layer_id(self) -&gt; Any:\n        \"\"\"\n        Get the identifier for the reinsurance contract layer.\n\n        Returns:\n            Any: The layer identifier.\n        \"\"\"\n        return self._layer_id\n\n    @layer_id.setter\n    def layer_id(self, lid: Any) -&gt; None:\n        \"\"\"\n        Set the identifier for the reinsurance contract layer.\n\n        Args:\n            lid (Any): The new layer identifier.\n        \"\"\"\n        self._layer_id = lid\n\n    @property\n    def a_priori(self) -&gt; Dict[int, float]:\n        \"\"\"\n        Get the a priori expected loss ratios for each modelling year.\n\n        Returns:\n            Dict[int, float]: Mapping of modelling year to a priori expected loss ratio.\n        \"\"\"\n        return self._a_priori\n\n    @a_priori.setter\n    def a_priori(self, prior: Dict[int, float]) -&gt; None:\n        \"\"\"\n        Set the a priori expected loss ratios for each modelling year.\n\n        Args:\n            prior (Dict[int, float]): Mapping of modelling year to a priori expected loss ratio.\n        \"\"\"\n        self._a_priori = prior\n\n    def calculate_burn_cost(self) -&gt; Dict[int, float]:\n        \"\"\"\n        Calculate the burn cost for each modelling year.\n\n        This method applies the specified projection method for each modelling year\n        to calculate the burn cost based on the claims and exposures data.\n\n        Returns:\n            Dict[int, float]: Mapping of modelling year to calculated burn cost.\n        \"\"\"\n        burn_costs = {}\n        for year in self._modelling_years:\n            # Skip years that don't have data in the aggregate claims or exposures\n            if (self._layer_id not in self._data.aggregate_subject_contract_claims or\n                year not in self._data.aggregate_subject_contract_claims[self._layer_id] or\n                year not in self._data.aggregate_exposures):\n                continue\n\n            # Get claims and exposures data for the year\n            claims_data = self._data.aggregate_subject_contract_claims[self._layer_id][year]\n            exposures_data = self._data.aggregate_exposures[year]\n\n            # Get the latest incurred claims amount\n            latest_incurred = claims_data.get(\"latest_incurred\", 0.0)\n\n            # Get the earned exposure value\n            earned_exposure = exposures_data.get(\"earned\", 0.0)\n\n            # Skip years with zero exposure to avoid division by zero\n            if earned_exposure == 0.0:\n                continue\n\n            # Get the projection method, development factor, and a priori for the year\n            method = self._projection_methods.get(year, ProjectionMethods.SIMPLE_CAPE_COD)\n            dev_factor = self._development_pattern.get(year, 1.0)\n            a_priori_value = self._a_priori.get(year, 0.0)\n\n            # Apply the projection method\n            projection_fn = projection_methods_fn.get(method)\n            try:\n                if method == ProjectionMethods.CHAINLADDER:\n                    ultimate_claims = projection_fn(latest_incurred, dev_factor)\n                elif method in [ProjectionMethods.SIMPLE_CAPE_COD, ProjectionMethods.GENERALISED_CAPE_COD]:\n                    # Collect data for all years to calculate the Cape Cod prior\n                    trend_factors = []\n                    losses = []\n                    dev_factors = []\n                    exposures_list = []\n\n                    for yr in self._modelling_years:\n                        if (yr in self._data.aggregate_subject_contract_claims.get(self._layer_id, {}) and \n                            yr in self._data.aggregate_exposures):\n                            yr_claims = self._data.aggregate_subject_contract_claims[self._layer_id][yr]\n                            yr_exposures = self._data.aggregate_exposures[yr]\n\n                            trend_factors.append(1.0)  # Default trend factor, could be replaced with actual trend factors\n                            losses.append(yr_claims.get(\"latest_incurred\", 0.0))\n                            dev_factors.append(self._development_pattern.get(yr, 1.0))\n                            exposures_list.append(yr_exposures.get(\"earned\", 0.0))\n\n                    decay_factor = 0.0  # Default decay factor, could be a parameter of the model\n\n                    if method == ProjectionMethods.SIMPLE_CAPE_COD:\n                        ultimate_claims = projection_fn(\n                            latest_incurred, earned_exposure, dev_factor,\n                            trend_factors, losses, dev_factors, exposures_list\n                        )\n                    else:  # GENERALISED_CAPE_COD\n                        ultimate_claims = projection_fn(\n                            latest_incurred, earned_exposure, dev_factor,\n                            trend_factors, losses, dev_factors, exposures_list, decay_factor\n                        )\n                else:  # BF\n                    ultimate_claims = projection_fn(latest_incurred, earned_exposure, dev_factor, a_priori_value)\n\n                # Calculate burn cost as ultimate claims divided by earned exposure\n                burn_costs[year] = ultimate_claims / earned_exposure if earned_exposure &gt; 0 else 0.0\n\n            except Exception as e:\n                # If there's an error, use the chainladder method as fallback\n                ultimate_claims = chainladder_method(latest_incurred, dev_factor)\n                burn_costs[year] = ultimate_claims / earned_exposure if earned_exposure &gt; 0 else 0.0\n\n        return burn_costs\n</code></pre>"},{"location":"models/#pyre.Models.Experience.burn_cost.BurnCostModel.a_priori","title":"<code>a_priori</code>  <code>property</code> <code>writable</code>","text":"<p>Get the a priori expected loss ratios for each modelling year.</p> <p>Returns:</p> Type Description <code>Dict[int, float]</code> <p>Dict[int, float]: Mapping of modelling year to a priori expected loss ratio.</p>"},{"location":"models/#pyre.Models.Experience.burn_cost.BurnCostModel.data","title":"<code>data</code>  <code>property</code> <code>writable</code>","text":"<p>Get the claims and exposures data for the reinsurance contract.</p> <p>Returns:</p> Name Type Description <code>ExperienceModelData</code> <code>ExperienceModelData</code> <p>The claims and exposures data.</p>"},{"location":"models/#pyre.Models.Experience.burn_cost.BurnCostModel.development_pattern","title":"<code>development_pattern</code>  <code>property</code> <code>writable</code>","text":"<p>Get the development factors for each modelling year.</p> <p>Returns:</p> Type Description <code>Dict[int, float]</code> <p>Dict[int, float]: Mapping of modelling year to development factor.</p>"},{"location":"models/#pyre.Models.Experience.burn_cost.BurnCostModel.layer_id","title":"<code>layer_id</code>  <code>property</code> <code>writable</code>","text":"<p>Get the identifier for the reinsurance contract layer.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The layer identifier.</p>"},{"location":"models/#pyre.Models.Experience.burn_cost.BurnCostModel.modelling_years","title":"<code>modelling_years</code>  <code>property</code> <code>writable</code>","text":"<p>Get the years to be used in the modelling.</p> <p>Returns:</p> Type Description <code>List[int]</code> <p>List[int]: The modelling years.</p>"},{"location":"models/#pyre.Models.Experience.burn_cost.BurnCostModel.projection_methods","title":"<code>projection_methods</code>  <code>property</code> <code>writable</code>","text":"<p>Get the projection method to use for each modelling year.</p> <p>Returns:</p> Type Description <code>Dict[int, ProjectionMethods]</code> <p>Dict[int, ProjectionMethods]: Mapping of modelling year to projection method.</p>"},{"location":"models/#pyre.Models.Experience.burn_cost.BurnCostModel.years_weighting","title":"<code>years_weighting</code>  <code>property</code> <code>writable</code>","text":"<p>Get the weighting factors for each modelling year.</p> <p>Returns:</p> Type Description <code>Dict[int, float]</code> <p>Dict[int, float]: Mapping of modelling year to weighting factor.</p>"},{"location":"models/#pyre.Models.Experience.burn_cost.BurnCostModel.__init__","title":"<code>__init__(model_data, layer_id, years_weighting=None, projection_methods=None, development_pattern=None, a_priori_assumption=None)</code>","text":"<p>Initialize a BurnCostModel instance.</p> <p>Parameters:</p> Name Type Description Default <code>model_data</code> <code>ExperienceModelData</code> <p>The claims and exposures data for the reinsurance contract.</p> required <code>layer_id</code> <code>Any</code> <p>The identifier for the reinsurance contract layer.</p> required <code>years_weighting</code> <code>Optional[Dict[int, float]]</code> <p>Weighting factors for each modelling year. If None, equal weights of 1.0 will be used for all years. Defaults to None.</p> <code>None</code> <code>projection_methods</code> <code>Optional[Dict[int, ProjectionMethods]]</code> <p>Projection method to use for each modelling year. If None, SIMPLE_CAPE_COD will be used for all years. Defaults to None.</p> <code>None</code> <code>development_pattern</code> <code>Optional[Dict[int, float]]</code> <p>Development factors for each modelling year. If None, factors of 1.0 will be used for all years (no development). Defaults to None.</p> <code>None</code> <code>a_priori_assumption</code> <code>Optional[Dict[int, float]]</code> <p>A priori expected loss ratios for each modelling year. If None, values of 0.0 will be used for all years (no a priori assumption). Defaults to None.</p> <code>None</code> Source code in <code>src\\pyre\\Models\\Experience\\burn_cost.py</code> <pre><code>def __init__(self,\n            model_data: ExperienceModelData, \n            layer_id: Any, \n            years_weighting: Optional[Dict[int, float]] = None, \n            projection_methods: Optional[Dict[int, ProjectionMethods]] = None,\n            development_pattern: Optional[Dict[int, float]] = None,\n            a_priori_assumption: Optional[Dict[int, float]] = None) -&gt; None:\n    \"\"\"\n    Initialize a BurnCostModel instance.\n\n    Args:\n        model_data (ExperienceModelData): The claims and exposures data for the reinsurance contract.\n        layer_id (Any): The identifier for the reinsurance contract layer.\n        years_weighting (Optional[Dict[int, float]], optional): Weighting factors for each modelling year.\n            If None, equal weights of 1.0 will be used for all years. Defaults to None.\n        projection_methods (Optional[Dict[int, ProjectionMethods]], optional): Projection method to use for each modelling year.\n            If None, SIMPLE_CAPE_COD will be used for all years. Defaults to None.\n        development_pattern (Optional[Dict[int, float]], optional): Development factors for each modelling year.\n            If None, factors of 1.0 will be used for all years (no development). Defaults to None.\n        a_priori_assumption (Optional[Dict[int, float]], optional): A priori expected loss ratios for each modelling year.\n            If None, values of 0.0 will be used for all years (no a priori assumption). Defaults to None.\n    \"\"\"\n    self._modelling_years = model_data.exposures.modelling_years\n    self._years_weighting = years_weighting if years_weighting else {year: 1.0 for year in model_data.exposures.modelling_years}\n    self._projection_methods = projection_methods if projection_methods else {year: ProjectionMethods.SIMPLE_CAPE_COD for year in model_data.exposures.modelling_years}  # Default to simple cape cod method\n    self._development_pattern = development_pattern if development_pattern else {year: 1.0 for year in model_data.exposures.modelling_years}  # Default to no development pattern\n    self._a_priori = a_priori_assumption if a_priori_assumption else {year: 0.0 for year in model_data.exposures.modelling_years}  # Default to no a priori assumption\n    self._data = model_data\n    self._layer_id = layer_id\n</code></pre>"},{"location":"models/#pyre.Models.Experience.burn_cost.BurnCostModel.calculate_burn_cost","title":"<code>calculate_burn_cost()</code>","text":"<p>Calculate the burn cost for each modelling year.</p> <p>This method applies the specified projection method for each modelling year to calculate the burn cost based on the claims and exposures data.</p> <p>Returns:</p> Type Description <code>Dict[int, float]</code> <p>Dict[int, float]: Mapping of modelling year to calculated burn cost.</p> Source code in <code>src\\pyre\\Models\\Experience\\burn_cost.py</code> <pre><code>def calculate_burn_cost(self) -&gt; Dict[int, float]:\n    \"\"\"\n    Calculate the burn cost for each modelling year.\n\n    This method applies the specified projection method for each modelling year\n    to calculate the burn cost based on the claims and exposures data.\n\n    Returns:\n        Dict[int, float]: Mapping of modelling year to calculated burn cost.\n    \"\"\"\n    burn_costs = {}\n    for year in self._modelling_years:\n        # Skip years that don't have data in the aggregate claims or exposures\n        if (self._layer_id not in self._data.aggregate_subject_contract_claims or\n            year not in self._data.aggregate_subject_contract_claims[self._layer_id] or\n            year not in self._data.aggregate_exposures):\n            continue\n\n        # Get claims and exposures data for the year\n        claims_data = self._data.aggregate_subject_contract_claims[self._layer_id][year]\n        exposures_data = self._data.aggregate_exposures[year]\n\n        # Get the latest incurred claims amount\n        latest_incurred = claims_data.get(\"latest_incurred\", 0.0)\n\n        # Get the earned exposure value\n        earned_exposure = exposures_data.get(\"earned\", 0.0)\n\n        # Skip years with zero exposure to avoid division by zero\n        if earned_exposure == 0.0:\n            continue\n\n        # Get the projection method, development factor, and a priori for the year\n        method = self._projection_methods.get(year, ProjectionMethods.SIMPLE_CAPE_COD)\n        dev_factor = self._development_pattern.get(year, 1.0)\n        a_priori_value = self._a_priori.get(year, 0.0)\n\n        # Apply the projection method\n        projection_fn = projection_methods_fn.get(method)\n        try:\n            if method == ProjectionMethods.CHAINLADDER:\n                ultimate_claims = projection_fn(latest_incurred, dev_factor)\n            elif method in [ProjectionMethods.SIMPLE_CAPE_COD, ProjectionMethods.GENERALISED_CAPE_COD]:\n                # Collect data for all years to calculate the Cape Cod prior\n                trend_factors = []\n                losses = []\n                dev_factors = []\n                exposures_list = []\n\n                for yr in self._modelling_years:\n                    if (yr in self._data.aggregate_subject_contract_claims.get(self._layer_id, {}) and \n                        yr in self._data.aggregate_exposures):\n                        yr_claims = self._data.aggregate_subject_contract_claims[self._layer_id][yr]\n                        yr_exposures = self._data.aggregate_exposures[yr]\n\n                        trend_factors.append(1.0)  # Default trend factor, could be replaced with actual trend factors\n                        losses.append(yr_claims.get(\"latest_incurred\", 0.0))\n                        dev_factors.append(self._development_pattern.get(yr, 1.0))\n                        exposures_list.append(yr_exposures.get(\"earned\", 0.0))\n\n                decay_factor = 0.0  # Default decay factor, could be a parameter of the model\n\n                if method == ProjectionMethods.SIMPLE_CAPE_COD:\n                    ultimate_claims = projection_fn(\n                        latest_incurred, earned_exposure, dev_factor,\n                        trend_factors, losses, dev_factors, exposures_list\n                    )\n                else:  # GENERALISED_CAPE_COD\n                    ultimate_claims = projection_fn(\n                        latest_incurred, earned_exposure, dev_factor,\n                        trend_factors, losses, dev_factors, exposures_list, decay_factor\n                    )\n            else:  # BF\n                ultimate_claims = projection_fn(latest_incurred, earned_exposure, dev_factor, a_priori_value)\n\n            # Calculate burn cost as ultimate claims divided by earned exposure\n            burn_costs[year] = ultimate_claims / earned_exposure if earned_exposure &gt; 0 else 0.0\n\n        except Exception as e:\n            # If there's an error, use the chainladder method as fallback\n            ultimate_claims = chainladder_method(latest_incurred, dev_factor)\n            burn_costs[year] = ultimate_claims / earned_exposure if earned_exposure &gt; 0 else 0.0\n\n    return burn_costs\n</code></pre>"},{"location":"models/#pyre.Models.Experience.burn_cost.ProjectionMethods","title":"<code>ProjectionMethods</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of available projection methods for burn cost calculations.</p> Source code in <code>src\\pyre\\Models\\Experience\\burn_cost.py</code> <pre><code>class ProjectionMethods(Enum):\n    \"\"\"\n    Enumeration of available projection methods for burn cost calculations.\n    \"\"\"\n    CHAINLADDER = auto()\n    BF = auto()\n    SIMPLE_CAPE_COD = auto()\n    GENERALISED_CAPE_COD = auto()\n</code></pre>"},{"location":"models/#pyre.Models.Experience.burn_cost.bf_method","title":"<code>bf_method(data, exposure, development_factor, a_priori)</code>","text":"<p>Apply the Bornhuetter-Ferguson method to project ultimate claims.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>float</code> <p>The current claim amount.</p> required <code>exposure</code> <code>float</code> <p>The exposure amount.</p> required <code>development_factor</code> <code>float</code> <p>The development factor to apply.</p> required <code>a_priori</code> <code>float</code> <p>The a priori expected loss ratio.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The projected ultimate claim amount.</p> Source code in <code>src\\pyre\\Models\\Experience\\burn_cost.py</code> <pre><code>def bf_method(data: float, exposure: float, development_factor: float, a_priori: float) -&gt; float:\n    \"\"\"\n    Apply the Bornhuetter-Ferguson method to project ultimate claims.\n\n    Args:\n        data (float): The current claim amount.\n        exposure (float): The exposure amount.\n        development_factor (float): The development factor to apply.\n        a_priori (float): The a priori expected loss ratio.\n\n    Returns:\n        float: The projected ultimate claim amount.\n    \"\"\"\n    return data + (1 - (1/development_factor)) * a_priori * exposure\n</code></pre>"},{"location":"models/#pyre.Models.Experience.burn_cost.cape_cod_method","title":"<code>cape_cod_method(data, exposure, development_factor, trend_factors=None, losses=None, development_factors=None, exposures=None)</code>","text":"<p>Apply the Cape Cod method to project ultimate claims.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>float</code> <p>The current claim amount.</p> required <code>exposure</code> <code>float</code> <p>The exposure amount.</p> required <code>development_factor</code> <code>float</code> <p>The development factor to apply.</p> required <code>trend_factors</code> <code>List[float]</code> <p>List of trend factors for each year.</p> <code>None</code> <code>losses</code> <code>List[float]</code> <p>List of losses for each year.</p> <code>None</code> <code>development_factors</code> <code>List[float]</code> <p>List of development factors for each year.</p> <code>None</code> <code>exposures</code> <code>List[float]</code> <p>List of exposures for each year.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The projected ultimate claim amount.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any of the required parameters for cape_cod_prior_algo are missing.</p> Source code in <code>src\\pyre\\Models\\Experience\\burn_cost.py</code> <pre><code>def cape_cod_method(data: float, exposure: float, development_factor: float, \n                    trend_factors: List[float] = None, losses: List[float] = None, \n                    development_factors: List[float] = None, exposures: List[float] = None) -&gt; float:\n    \"\"\"\n    Apply the Cape Cod method to project ultimate claims.\n\n    Args:\n        data (float): The current claim amount.\n        exposure (float): The exposure amount.\n        development_factor (float): The development factor to apply.\n        trend_factors (List[float], optional): List of trend factors for each year.\n        losses (List[float], optional): List of losses for each year.\n        development_factors (List[float], optional): List of development factors for each year.\n        exposures (List[float], optional): List of exposures for each year.\n\n    Returns:\n        float: The projected ultimate claim amount.\n\n    Raises:\n        ValueError: If any of the required parameters for cape_cod_prior_algo are missing.\n    \"\"\"\n    # If any of the required parameters for cape_cod_prior_algo are missing, raise an error\n    if not all([trend_factors, losses, development_factors, exposures]):\n        raise ValueError(\"Cape Cod method requires trend_factors, losses, development_factors, and exposures\")\n\n    cape_cod_prior = cape_cod_prior_algo(\n        trend_factors=trend_factors,\n        losses=losses,\n        development_factors=development_factors,\n        exposures=exposures,\n        generalised=False\n    )\n\n    return bf_method(data, exposure, development_factor, a_priori=cape_cod_prior)\n</code></pre>"},{"location":"models/#pyre.Models.Experience.burn_cost.cape_cod_prior_algo","title":"<code>cape_cod_prior_algo(trend_factors, losses, development_factors, exposures, decay_factor=0.0, generalised=False)</code>","text":"<p>Calculate the a priori expected loss ratio using the Cape Cod algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>trend_factors</code> <code>List[float]</code> <p>List of trend factors for each year.</p> required <code>losses</code> <code>List[float]</code> <p>List of losses for each year.</p> required <code>development_factors</code> <code>List[float]</code> <p>List of development factors for each year.</p> required <code>exposures</code> <code>List[float]</code> <p>List of exposures for each year.</p> required <code>decay_factor</code> <code>float</code> <p>Decay factor for the generalised method. Defaults to 0.0.</p> <code>0.0</code> <code>generalised</code> <code>bool</code> <p>Whether to use the generalised method. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[Any, float]</code> <p>Union[Any, float]: The a priori expected loss ratio.</p> Source code in <code>src\\pyre\\Models\\Experience\\burn_cost.py</code> <pre><code>def cape_cod_prior_algo(trend_factors: List[float], losses: List[float], development_factors: List[float],\n                        exposures: List[float], decay_factor: float = 0.0, generalised: bool = False) -&gt; Union[\n    Any, float]:\n    \"\"\"\n    Calculate the a priori expected loss ratio using the Cape Cod algorithm.\n\n    Args:\n        trend_factors (List[float]): List of trend factors for each year.\n        losses (List[float]): List of losses for each year.\n        development_factors (List[float]): List of development factors for each year.\n        exposures (List[float]): List of exposures for each year.\n        decay_factor (float, optional): Decay factor for the generalised method. Defaults to 0.0.\n        generalised (bool, optional): Whether to use the generalised method. Defaults to False.\n\n    Returns:\n        Union[Any, float]: The a priori expected loss ratio.\n    \"\"\"\n    if generalised:\n        # For the generalized method, we apply a decay factor to give different weights to different years\n        weights = [exp(-decay_factor * i) for i in range(len(trend_factors))]\n\n        # Calculate weighted pseudo claims and exposures\n        psuedo_claims = sum(weights[i] * trend_factors[i] * losses[i] * (development_factors[i] / exposures[i])\n                            for i in range(len(trend_factors)))\n        psuedo_exposures = sum(weights[i] * exposures[i] / development_factors[i]\n                               for i in range(len(exposures)))\n\n        return psuedo_claims / psuedo_exposures\n    else:\n        # Standard Cape Cod method (already implemented)\n        psuedo_claims = sum(trend_factors[i] * losses[i] * (development_factors[i] / exposures[i])\n                            for i in range(len(trend_factors)))\n        psuedo_exposures = sum(exposures[i] / development_factors[i]\n                               for i in range(len(exposures)))\n        return psuedo_claims / psuedo_exposures\n</code></pre>"},{"location":"models/#pyre.Models.Experience.burn_cost.chainladder_method","title":"<code>chainladder_method(data, development_factor)</code>","text":"<p>Apply the Chain Ladder method to project ultimate claims.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>float</code> <p>The current claim amount.</p> required <code>development_factor</code> <code>float</code> <p>The development factor to apply.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The projected ultimate claim amount.</p> Source code in <code>src\\pyre\\Models\\Experience\\burn_cost.py</code> <pre><code>def chainladder_method(data: float, development_factor: float) -&gt; float:\n    \"\"\"\n    Apply the Chain Ladder method to project ultimate claims.\n\n    Args:\n        data (float): The current claim amount.\n        development_factor (float): The development factor to apply.\n\n    Returns:\n        float: The projected ultimate claim amount.\n    \"\"\"\n    return data * development_factor\n</code></pre>"},{"location":"models/#pyre.Models.Experience.burn_cost.generalised_cape_cod_method","title":"<code>generalised_cape_cod_method(data, exposure, development_factor, trend_factors=None, losses=None, development_factors=None, exposures=None, decay_factor=0.0)</code>","text":"<p>Apply the Generalised Cape Cod method to project ultimate claims.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>float</code> <p>The current claim amount.</p> required <code>exposure</code> <code>float</code> <p>The exposure amount.</p> required <code>development_factor</code> <code>float</code> <p>The development factor to apply.</p> required <code>trend_factors</code> <code>List[float]</code> <p>List of trend factors for each year.</p> <code>None</code> <code>losses</code> <code>List[float]</code> <p>List of losses for each year.</p> <code>None</code> <code>development_factors</code> <code>List[float]</code> <p>List of development factors for each year.</p> <code>None</code> <code>exposures</code> <code>List[float]</code> <p>List of exposures for each year.</p> <code>None</code> <code>decay_factor</code> <code>float</code> <p>Decay factor for the generalised method. Defaults to 0.0.</p> <code>0.0</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The projected ultimate claim amount.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any of the required parameters for cape_cod_prior_algo are missing.</p> Source code in <code>src\\pyre\\Models\\Experience\\burn_cost.py</code> <pre><code>def generalised_cape_cod_method(data: float, exposure: float, development_factor: float,\n                               trend_factors: List[float] = None, losses: List[float] = None,\n                               development_factors: List[float] = None, exposures: List[float] = None,\n                               decay_factor: float = 0.0) -&gt; float:\n    \"\"\"\n    Apply the Generalised Cape Cod method to project ultimate claims.\n\n    Args:\n        data (float): The current claim amount.\n        exposure (float): The exposure amount.\n        development_factor (float): The development factor to apply.\n        trend_factors (List[float], optional): List of trend factors for each year.\n        losses (List[float], optional): List of losses for each year.\n        development_factors (List[float], optional): List of development factors for each year.\n        exposures (List[float], optional): List of exposures for each year.\n        decay_factor (float, optional): Decay factor for the generalised method. Defaults to 0.0.\n\n    Returns:\n        float: The projected ultimate claim amount.\n\n    Raises:\n        ValueError: If any of the required parameters for cape_cod_prior_algo are missing.\n    \"\"\"\n    # If any of the required parameters for cape_cod_prior_algo are missing, raise an error\n    if not all([trend_factors, losses, development_factors, exposures]):\n        raise ValueError(\"Generalised Cape Cod method requires trend_factors, losses, development_factors, and exposures\")\n\n    generalised_cape_cod_prior = cape_cod_prior_algo(\n        trend_factors=trend_factors,\n        losses=losses,\n        development_factors=development_factors,\n        exposures=exposures,\n        decay_factor=decay_factor,\n        generalised=True\n    )\n\n    return bf_method(data, exposure, development_factor, a_priori=generalised_cape_cod_prior)\n</code></pre>"},{"location":"models/#pyre.Models.Experience.curve_fitting.assess_error_assumptions","title":"<code>assess_error_assumptions(actual, expected, num_parameters)</code>","text":"<p>Assesses the error term based on standardized residuals and calculates: - The proportion of positive standardized residuals. - The proportion of standardized residuals outside the range (-2, 2).</p> <p>Parameters:</p> Name Type Description Default <code>actual</code> <code>List[float]</code> <p>The actual observed values.</p> required <code>expected</code> <code>List[float]</code> <p>The expected values from the model.</p> required <code>num_parameters</code> <code>int</code> <p>The number of parameters in the model.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing: - 'proportion_positive': Proportion of positive standardized residuals. - 'proportion_outside_range': Proportion of standardized residuals outside (-2, 2). - 'mean_residual': Mean of the standardized residuals. - 'std_residual': Standard deviation of the standardized residuals.</p> Source code in <code>src\\pyre\\Models\\Experience\\curve_fitting.py</code> <pre><code>def assess_error_assumptions(actual: List[float], expected: List[float], num_parameters: int) -&gt; dict:\n    \"\"\"\n    Assesses the error term based on standardized residuals and calculates:\n    - The proportion of positive standardized residuals.\n    - The proportion of standardized residuals outside the range (-2, 2).\n\n    Args:\n        actual (List[float]): The actual observed values.\n        expected (List[float]): The expected values from the model.\n        num_parameters (int): The number of parameters in the model.\n\n    Returns:\n        dict: A dictionary containing:\n            - 'proportion_positive': Proportion of positive standardized residuals.\n            - 'proportion_outside_range': Proportion of standardized residuals outside (-2, 2).\n            - 'mean_residual': Mean of the standardized residuals.\n            - 'std_residual': Standard deviation of the standardized residuals.\n    \"\"\"\n    # Calculate standardized residuals\n    residuals = residuals_standardised(actual, expected, num_parameters)\n\n    # Proportion of positive standardized residuals\n    proportion_positive = sum(1 for r in residuals if r &gt; 0) / len(residuals)\n\n    # Proportion of standardized residuals outside the range (-2, 2)\n    proportion_outside_range = sum(1 for r in residuals if r &lt; -2 or r &gt; 2) / len(residuals)\n\n    # Mean and standard deviation of standardized residuals\n    mean_residual = sum(residuals) / len(residuals)\n    std_residual = sqrt(sum((r - mean_residual) ** 2 for r in residuals) / len(residuals))\n\n    return {\n        \"proportion_positive\": proportion_positive,\n        \"proportion_outside_range\": proportion_outside_range,\n        \"mean_residual\": mean_residual,\n        \"std_residual\": std_residual,\n    }\n</code></pre>"},{"location":"models/#pyre.Models.Experience.curve_fitting.exponential_fit","title":"<code>exponential_fit(age_to_age_factors, time_periods)</code>","text":"<p>Fits an exponential curve to the given age-to-age factors using the model: rj = exp(a + b * t), where ln(rj) = a + b * t.</p> <p>Parameters:</p> Name Type Description Default <code>age_to_age_factors</code> <code>List[float]</code> <p>The incremental age-to-age factors (rj).</p> required <code>time_periods</code> <code>List[int]</code> <p>The corresponding time periods (t).</p> required <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>List[float]: A list containing the parameters [a, b] of the exponential curve.</p> Source code in <code>src\\pyre\\Models\\Experience\\curve_fitting.py</code> <pre><code>def exponential_fit(age_to_age_factors: List[float], time_periods: List[float]) -&gt; Tuple[float,float]:\n    \"\"\"\n    Fits an exponential curve to the given age-to-age factors using the model:\n    rj = exp(a + b * t), where ln(rj) = a + b * t.\n\n    Args:\n        age_to_age_factors (List[float]): The incremental age-to-age factors (rj).\n        time_periods (List[int]): The corresponding time periods (t).\n\n    Returns:\n        List[float]: A list containing the parameters [a, b] of the exponential curve.\n    \"\"\"\n    ln_rj = [log(rj - 1) for rj in age_to_age_factors]\n    b, a = linear_regression(time_periods, ln_rj)\n    return (a, b)\n</code></pre>"},{"location":"models/#pyre.Models.Experience.curve_fitting.inverse_power_fit","title":"<code>inverse_power_fit(age_to_age_factors, time_periods, c_values)</code>","text":"<p>Fits a Sherman Curve (Inverse Power Curve) to the given incremental age-to-age factors using the model: rj = a * (t + c)^b.</p> <p>Parameters:</p> Name Type Description Default <code>age_to_age_factors</code> <code>List[float]</code> <p>The incremental age-to-age factors (rj).</p> required <code>time_periods</code> <code>List[int]</code> <p>The corresponding time periods (t).</p> required <code>c_values</code> <code>List[float]</code> <p>A list of candidate values for c to test.</p> required <p>Returns:</p> Type Description <code>Tuple[float, float, float]</code> <p>List[float]: A list containing the parameters [a, b, c] of the Sherman Curve.</p> Source code in <code>src\\pyre\\Models\\Experience\\curve_fitting.py</code> <pre><code>def inverse_power_fit(age_to_age_factors: List[float], time_periods: List[float], c_values: List[float]) -&gt; Tuple[float, float, float]:\n    \"\"\"\n    Fits a Sherman Curve (Inverse Power Curve) to the given incremental age-to-age factors using the model:\n    rj = a * (t + c)^b.\n\n    Args:\n        age_to_age_factors (List[float]): The incremental age-to-age factors (rj).\n        time_periods (List[int]): The corresponding time periods (t).\n        c_values (List[float]): A list of candidate values for c to test.\n\n    Returns:\n        List[float]: A list containing the parameters [a, b, c] of the Sherman Curve.\n    \"\"\"\n    def calculate_standard_error(a: float, b: float, c: float) -&gt; float:\n        predicted_rj = [a * ((t + c) ** b) for t in time_periods]\n        errors = [(rj - pred_rj) ** 2 for rj, pred_rj in zip(age_to_age_factors, predicted_rj)]\n        return sqrt(sum(errors) / len(errors))\n\n    best_a, best_b, best_c = 0.0, 0.0, 0.0\n    min_standard_error = float('inf')\n\n    for c in c_values:\n        ln_rj = [log(rj - 1) for rj in age_to_age_factors]\n        ln_t_plus_c = [log(t + c) for t in time_periods]\n        b, ln_a = linear_regression(ln_t_plus_c, ln_rj)\n        a = exp(ln_a)\n        standard_error = calculate_standard_error(a, b, c)\n\n        if standard_error &lt; min_standard_error:\n            min_standard_error = standard_error\n            best_a, best_b, best_c = a, b, c\n\n    return (best_a, best_b, best_c)\n</code></pre>"},{"location":"models/#pyre.Models.Experience.curve_fitting.linear_regression","title":"<code>linear_regression(x, y)</code>","text":"<p>Performs linear regression to calculate the slope and intercept.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>List[float]</code> <p>The independent variable values.</p> required <code>y</code> <code>List[float]</code> <p>The dependent variable values.</p> required <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple[float, float]: The slope and intercept of the regression line.</p> Source code in <code>src\\pyre\\Models\\Experience\\curve_fitting.py</code> <pre><code>def linear_regression(x: List[float], y: List[float]) -&gt; Tuple[float, float]:\n    \"\"\"\n    Performs linear regression to calculate the slope and intercept.\n\n    Args:\n        x (List[float]): The independent variable values.\n        y (List[float]): The dependent variable values.\n\n    Returns:\n        Tuple[float, float]: The slope and intercept of the regression line.\n    \"\"\"\n    mean_x = sum(x) / len(x)\n    mean_y = sum(y) / len(y)\n\n    numerator = sum((xi - mean_x) * (yi - mean_y) for xi, yi in zip(x, y))\n    denominator = sum((xi - mean_x) ** 2 for xi in x)\n\n    slope = numerator / denominator\n    intercept = mean_y - slope * mean_x\n\n    return (slope, intercept)\n</code></pre>"},{"location":"models/#pyre.Models.Experience.curve_fitting.power_fit","title":"<code>power_fit(age_to_age_factors, time_periods)</code>","text":"<p>Fits a power curve to the given cumulative age-to-age factors using the model: Rj = a * (b^t), where ln(ln(Rj)) = ln(ln(a)) + (ln(b) * t).</p> <p>Parameters:</p> Name Type Description Default <code>age_to_age_factors</code> <code>List[float]</code> <p>The cumulative age-to-age factors (Rj).</p> required <code>time_periods</code> <code>List[int]</code> <p>The corresponding time periods (t).</p> required <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>List[float]: A list containing the parameters [a, b] of the power curve.</p> Source code in <code>src\\pyre\\Models\\Experience\\curve_fitting.py</code> <pre><code>def power_fit(age_to_age_factors: List[float], time_periods: List[float]) -&gt; Tuple[float,float]:\n    \"\"\"\n    Fits a power curve to the given cumulative age-to-age factors using the model:\n    Rj = a * (b^t), where ln(ln(Rj)) = ln(ln(a)) + (ln(b) * t).\n\n    Args:\n        age_to_age_factors (List[float]): The cumulative age-to-age factors (Rj).\n        time_periods (List[int]): The corresponding time periods (t).\n\n    Returns:\n        List[float]: A list containing the parameters [a, b] of the power curve.\n    \"\"\"\n    ln_ln_Rj = [log(log(Rj)) for Rj in age_to_age_factors]\n    ln_b, ln_ln_a = linear_regression(time_periods, ln_ln_Rj)\n    a = exp(exp(ln_ln_a))\n    b = exp(ln_b)\n    return (a, b)\n</code></pre>"},{"location":"models/#pyre.Models.Experience.curve_fitting.r_squared","title":"<code>r_squared(actual, expected)</code>","text":"<p>Calculates the R-squared (coefficient of determination) value.</p> <p>Parameters:</p> Name Type Description Default <code>actual</code> <code>List[float]</code> <p>The actual observed values.</p> required <code>expected</code> <code>List[float]</code> <p>The expected values from the model.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The R-squared value.</p> Source code in <code>src\\pyre\\Models\\Experience\\curve_fitting.py</code> <pre><code>def r_squared(actual: List[float], expected: List[float]) -&gt; float:\n    \"\"\"\n    Calculates the R-squared (coefficient of determination) value.\n\n    Args:\n        actual (List[float]): The actual observed values.\n        expected (List[float]): The expected values from the model.\n\n    Returns:\n        float: The R-squared value.\n    \"\"\"\n    # Calculate the total sum of squares (TSS)\n    mean_actual = sum(actual) / len(actual)\n    total_sum_of_squares = sum((a - mean_actual) ** 2 for a in actual)\n\n    # Calculate the residual sum of squares (RSS)\n    residual_sum_of_squares = sum((a - e) ** 2 for a, e in zip(actual, expected))\n\n    # Calculate R-squared\n    r_squared_value = 1 - (residual_sum_of_squares / total_sum_of_squares)\n\n    return r_squared_value\n</code></pre>"},{"location":"models/#pyre.Models.Experience.curve_fitting.weibull_fit","title":"<code>weibull_fit(age_to_age_factors, time_periods)</code>","text":"<p>Fits a Weibull curve to the given cumulative age-to-age factors using the model: Rj = 1 / (1 - exp(-a * t^b)).</p> <p>Parameters:</p> Name Type Description Default <code>age_to_age_factors</code> <code>List[float]</code> <p>The cumulative age-to-age factors (Rj).</p> required <code>time_periods</code> <code>List[int]</code> <p>The corresponding time periods (t).</p> required <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>List[float]: A list containing the parameters [a, b] of the Weibull curve.</p> Source code in <code>src\\pyre\\Models\\Experience\\curve_fitting.py</code> <pre><code>def weibull_fit(age_to_age_factors: List[float], time_periods: List[float]) -&gt; Tuple[float,float]:\n    \"\"\"\n    Fits a Weibull curve to the given cumulative age-to-age factors using the model:\n    Rj = 1 / (1 - exp(-a * t^b)).\n\n    Args:\n        age_to_age_factors (List[float]): The cumulative age-to-age factors (Rj).\n        time_periods (List[int]): The corresponding time periods (t).\n\n    Returns:\n        List[float]: A list containing the parameters [a, b] of the Weibull curve.\n    \"\"\"\n    transformed_Rj = [log(-log(1 - 1 / Rj)) for Rj in age_to_age_factors]\n    ln_t = [log(t) for t in time_periods]\n    b, ln_a = linear_regression(ln_t, transformed_Rj)\n    a = exp(ln_a)\n    return (a, b)\n</code></pre>"},{"location":"models/#pyre.Models.Experience.frequency_severity.severity_fit","title":"<code>severity_fit</code>","text":"Source code in <code>src\\pyre\\Models\\Experience\\frequency_severity.py</code> <pre><code>class severity_fit:\n    def __init__(self, distributions: List[SeverityDistribution], data : ExperienceModelData, ibner_dev_pattern: Dict[int, float], ground_up:bool = True):\n        self.data = data\n        self.ground_up_model = ground_up\n        self.ibner_dev_pattern = ibner_dev_pattern # could pass IBNERPatternExtractor().getIBNERPATTERN as outputs Dict[int,float] if needed\n        self.distributions = distributions\n\n    @property\n    def _inidividual_projected_claims(self) -&gt; Any | List[float]:\n        if self.ground_up_model: \n            [claim.capped_claim_development_history.latest_incurred * self.ibner_dev_pattern[claim.claims_meta_data.modelling_year] for claim in self.data.trended_claims.claims]\n        else: \n            return NotImplementedError(\"non groud up fitting hasn't been implemented yet\") \n\n\n    def fit(self):\n        \"\"\"\n        Fit the severity distribution to the data.\n        This method should implement the logic to fit the specified severity distributions\n        to the data provided in the ExperienceModelData instance.\n        \"\"\"\n        self._inidividual_projected_claims \n        pass\n</code></pre>"},{"location":"models/#pyre.Models.Experience.frequency_severity.severity_fit.fit","title":"<code>fit()</code>","text":"<p>Fit the severity distribution to the data. This method should implement the logic to fit the specified severity distributions to the data provided in the ExperienceModelData instance.</p> Source code in <code>src\\pyre\\Models\\Experience\\frequency_severity.py</code> <pre><code>def fit(self):\n    \"\"\"\n    Fit the severity distribution to the data.\n    This method should implement the logic to fit the specified severity distributions\n    to the data provided in the ExperienceModelData instance.\n    \"\"\"\n    self._inidividual_projected_claims \n    pass\n</code></pre>"},{"location":"models/#pyre.Models.Experience.resampling.resampling","title":"<code>resampling</code>","text":"<p>A class for resampling claims data from an ExperienceModelData object.</p> <p>This class provides functionality to randomly select claims from a set of trended claims for the purpose of simulation or bootstrapping analysis. It uses the random.choice function to select individual claims from the trended claims data.</p> <p>Attributes:</p> Name Type Description <code>_claims</code> <p>A collection of trended claims from the ExperienceModelData object.     These are claims that have been adjusted to the contract inception year.</p> Note <p>Future enhancements planned include support for different return periods and more sophisticated resampling methods. The implementation relies on the Claims class having an iterator method to work with the random.choice function.</p> Source code in <code>src\\pyre\\Models\\Experience\\resampling.py</code> <pre><code>class resampling():\n    \"\"\"\n    A class for resampling claims data from an ExperienceModelData object.\n\n    This class provides functionality to randomly select claims from a set of trended claims\n    for the purpose of simulation or bootstrapping analysis. It uses the random.choice function\n    to select individual claims from the trended claims data.\n\n    Attributes:\n        _claims: A collection of trended claims from the ExperienceModelData object.\n                These are claims that have been adjusted to the contract inception year.\n\n    Note:\n        Future enhancements planned include support for different return periods and\n        more sophisticated resampling methods. The implementation relies on the Claims\n        class having an iterator method to work with the random.choice function.\n    \"\"\"\n    def __init__(self, claims: ExperienceModelData) -&gt; None:\n        \"\"\"\n        Initialize the resampling class with claims data.\n\n        Parameters:\n            claims (ExperienceModelData): An ExperienceModelData object containing the claims\n                                         to be resampled. The trended_claims property of this\n                                         object will be used for resampling.\n        \"\"\"\n        self._claims = ExperienceModelData.trended_claims #trended loss prior to subject losses\n\n\n    def resample(self) -&gt; None:\n        \"\"\"\n        Randomly select a claim from the collection of trended claims.\n\n        This method uses the random.choice function to select a single claim\n        from the trended claims data. Currently, it doesn't return the selected\n        claim but this behavior may change in future implementations.\n\n        Returns:\n            None: Currently doesn't return anything, but may be updated to return\n                 the selected claim in future implementations.\n\n        Note:\n            Future enhancements will include support for different return periods\n            and more sophisticated resampling methods.\n        \"\"\"\n        choice(self._claims)\n</code></pre>"},{"location":"models/#pyre.Models.Experience.resampling.resampling.__init__","title":"<code>__init__(claims)</code>","text":"<p>Initialize the resampling class with claims data.</p> <p>Parameters:</p> Name Type Description Default <code>claims</code> <code>ExperienceModelData</code> <p>An ExperienceModelData object containing the claims                          to be resampled. The trended_claims property of this                          object will be used for resampling.</p> required Source code in <code>src\\pyre\\Models\\Experience\\resampling.py</code> <pre><code>def __init__(self, claims: ExperienceModelData) -&gt; None:\n    \"\"\"\n    Initialize the resampling class with claims data.\n\n    Parameters:\n        claims (ExperienceModelData): An ExperienceModelData object containing the claims\n                                     to be resampled. The trended_claims property of this\n                                     object will be used for resampling.\n    \"\"\"\n    self._claims = ExperienceModelData.trended_claims #trended loss prior to subject losses\n</code></pre>"},{"location":"models/#pyre.Models.Experience.resampling.resampling.resample","title":"<code>resample()</code>","text":"<p>Randomly select a claim from the collection of trended claims.</p> <p>This method uses the random.choice function to select a single claim from the trended claims data. Currently, it doesn't return the selected claim but this behavior may change in future implementations.</p> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Currently doesn't return anything, but may be updated to return  the selected claim in future implementations.</p> Note <p>Future enhancements will include support for different return periods and more sophisticated resampling methods.</p> Source code in <code>src\\pyre\\Models\\Experience\\resampling.py</code> <pre><code>def resample(self) -&gt; None:\n    \"\"\"\n    Randomly select a claim from the collection of trended claims.\n\n    This method uses the random.choice function to select a single claim\n    from the trended claims data. Currently, it doesn't return the selected\n    claim but this behavior may change in future implementations.\n\n    Returns:\n        None: Currently doesn't return anything, but may be updated to return\n             the selected claim in future implementations.\n\n    Note:\n        Future enhancements will include support for different return periods\n        and more sophisticated resampling methods.\n    \"\"\"\n    choice(self._claims)\n</code></pre>"},{"location":"models/#pyre.Models.Exposure.mbbefd.swissRe_c_values","title":"<code>swissRe_c_values</code>","text":"<p>               Bases: <code>Enum</code></p> <p>summary https://www.swissre.com/dam/jcr:7137dac0-83a6-4cfa-80a4-93d33c35562f/exposure-rating-brochure.pdf</p> Source code in <code>src\\pyre\\Models\\Exposure\\mbbefd.py</code> <pre><code>class swissRe_c_values(Enum):\n    \"\"\"_summary_\n    https://www.swissre.com/dam/jcr:7137dac0-83a6-4cfa-80a4-93d33c35562f/exposure-rating-brochure.pdf\n    \"\"\"\n    PERSONAL_LINES = 1.5\n    COMMERCIAL_LINES_SMALL = 2.0\n    COMMERCIAL_LINES_MEDIUM = 3.0\n    CAPTIVE_BI = 2.1\n    CAPTIVE_PD = 3.8\n    CAPTIVE_BI_PD = 3.4\n    INDUSTRIAL_LARGE_COMMERCIAL = 4.0\n    LLOYDS_INDUSTRY = 5.0\n</code></pre>"},{"location":"models/#pyre.Models.Exposure.mbbefd.mbbefd_curve","title":"<code>mbbefd_curve(swissRe_c_values, curve_position)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>swissRe_c_values</code> <code>swissRe_c_values</code> <p>description</p> required <code>curve_position</code> <code>float</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>description</p> Source code in <code>src\\pyre\\Models\\Exposure\\mbbefd.py</code> <pre><code>def mbbefd_curve(swissRe_c_values: swissRe_c_values, curve_position:float) -&gt; float:\n    \"\"\"_summary_\n\n    Args:\n        swissRe_c_values (swissRe_c_values): _description_\n        curve_position (float): _description_\n\n    Returns:\n        float: _description_\n    \"\"\"\n    b = exp(3.1 - 0.15 * (1 + swissRe_c_values.value) * swissRe_c_values.value)\n    g = exp((0.78 + 0.12 * swissRe_c_values.value) * swissRe_c_values.value)\n    return log(((g - 1) * b + (1 - b * g) * b ** curve_position) / (1 - b)) / log(b * g)\n</code></pre>"},{"location":"models/#pyre.Models.Exposure.mixed_exponential.mixed_exponential_curve","title":"<code>mixed_exponential_curve(paramaters_mus, parameter_weights, curve_position_value)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>paramaters_mus</code> <code>list[float]</code> <p>description</p> required <code>parameter_weights</code> <code>list[float]</code> <p>description</p> required <code>curve_position_value</code> <code>float</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>description</p> Source code in <code>src\\pyre\\Models\\Exposure\\mixed_exponential.py</code> <pre><code>def mixed_exponential_curve(paramaters_mus:list[float], parameter_weights:list[float], curve_position_value:float) -&gt; float:\n    \"\"\"_summary_\n\n    Args:\n        paramaters_mus (list[float]): _description_\n        parameter_weights (list[float]): _description_\n        curve_position_value (float): _description_\n\n    Returns:\n        float: _description_\n    \"\"\"\n    total_limited_severity = 0\n    for mu, weight in zip(paramaters_mus, parameter_weights):\n        if mu != 0:  \n            contributing_limiting_severity = (1 - exp((-1 / mu) * curve_position_value)) * mu\n            total_limited_severity += contributing_limiting_severity * weight\n    return total_limited_severity\n</code></pre>"},{"location":"models/#pyre.Models.Exposure.riebesell.riebesell_curve","title":"<code>riebesell_curve(attachment, limit, z_value, base_limit)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>attachment</code> <code>float</code> <p>description</p> required <code>limit</code> <code>float</code> <p>description</p> required <code>z_value</code> <code>float</code> <p>description</p> required <code>base_limit</code> <code>float</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>_type_</code> <p>description</p> Source code in <code>src\\pyre\\Models\\Exposure\\riebesell.py</code> <pre><code>def riebesell_curve(attachment:float, limit:float, z_value:float, base_limit:float):\n    \"\"\"_summary_\n\n    Args:\n        attachment (float): _description_\n        limit (float): _description_\n        z_value (float): _description_\n        base_limit (float): _description_\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n    if limit is None:\n        return ((attachment) / base_limit) ** log(1 + z_value, 2)\n    else:\n        return ((attachment + limit) / base_limit) ** log(1 + z_value, 2)\n</code></pre>"},{"location":"models/#pyre.Models.AggregateFeatures.selections.CredibilityWeight","title":"<code>CredibilityWeight</code>","text":"Source code in <code>src\\pyre\\Models\\AggregateFeatures\\selections.py</code> <pre><code>class CredibilityWeight:\n    def __init__(self, experience_data: ExperienceModelData, exposure_data: ExposureModelData) -&gt; None:\n        \"\"\"\n        Initialize the CredibilityWeight class with experience and exposure data.\n\n        Args:\n            experience_data: Experience model data containing claims and exposures\n            exposure_data: Exposure model data containing exposures\n        \"\"\"\n        self.experience_data = experience_data\n        self.exposure_data = exposure_data\n\n    def calculate_sample_variance(self, data: List[float]) -&gt; float:\n        \"\"\"\n        Calculate the sample variance of a list of data points.\n\n        Args:\n            data: List of observed values\n\n        Returns:\n            Sample variance of the data\n        \"\"\"\n        if not data or len(data) &lt; 2:\n            return 0.0\n\n        mean = sum(data) / len(data)\n        variance = sum((x - mean) ** 2 for x in data) / (len(data) - 1)  # Using n-1 for sample variance\n\n        return variance\n\n    def calculate_data_variance(self, data: List[float], method: str = \"sample\") -&gt; float:\n        \"\"\"\n        Calculate the variance of data using different methods.\n\n        Args:\n            data: List of observed values\n            method: Method to use for variance calculation:\n                   \"sample\" - standard sample variance\n                   \"population\" - population variance\n                   \"process\" - estimate of process variance for credibility\n\n        Returns:\n            Variance of the data based on the specified method\n        \"\"\"\n        if not data or len(data) &lt; 2:\n            return 0.0\n\n        mean = sum(data) / len(data)\n\n        if method == \"sample\":\n            # Sample variance (unbiased estimator)\n            return sum((x - mean) ** 2 for x in data) / (len(data) - 1)\n        elif method == \"population\":\n            # Population variance\n            return sum((x - mean) ** 2 for x in data) / len(data)\n        elif method == \"process\":\n            # Process variance estimate for credibility calculations\n            # This is often the within-variance component\n            return sum((x - mean) ** 2 for x in data) / len(data)\n        else:\n            raise ValueError(f\"Invalid variance calculation method: {method}\")\n\n    def estimate_process_variance(self, data_by_group: Dict[Any, List[float]]) -&gt; float:\n        \"\"\"\n        Estimate the process variance (within variance) from grouped data.\n        This is useful for B\u00fchlmann and B\u00fchlmann-Straub credibility methods.\n\n        Args:\n            data_by_group: Dictionary mapping group identifiers to lists of observed values\n\n        Returns:\n            Estimated process variance\n        \"\"\"\n        if not data_by_group:\n            return 0.0\n\n        total_variance = 0.0\n        total_weight = 0.0\n\n        for group, values in data_by_group.items():\n            if len(values) &lt; 2:\n                continue\n\n            # Calculate within-group variance\n            group_mean = sum(values) / len(values)\n            group_variance = sum((x - group_mean) ** 2 for x in values) / len(values)\n\n            # Weight by group size\n            weight = len(values)\n            total_variance += group_variance * weight\n            total_weight += weight\n\n        if total_weight &lt;= 0:\n            return 0.0\n\n        return total_variance / total_weight\n\n    def estimate_variance_of_hypothetical_means(self, data_by_group: Dict[Any, List[float]]) -&gt; float:\n        \"\"\"\n        Estimate the variance of hypothetical means (between variance) from grouped data.\n        This is useful for B\u00fchlmann and B\u00fchlmann-Straub credibility methods.\n\n        Args:\n            data_by_group: Dictionary mapping group identifiers to lists of observed values\n\n        Returns:\n            Estimated variance of hypothetical means\n        \"\"\"\n        if not data_by_group:\n            return 0.0\n\n        # Calculate overall mean\n        all_values = []\n        for values in data_by_group.values():\n            all_values.extend(values)\n\n        if not all_values:\n            return 0.0\n\n        overall_mean = sum(all_values) / len(all_values)\n\n        # Calculate group means\n        group_means = {}\n        group_sizes = {}\n\n        for group, values in data_by_group.items():\n            if not values:\n                continue\n\n            group_means[group] = sum(values) / len(values)\n            group_sizes[group] = len(values)\n\n        # Calculate variance of group means\n        weighted_sum_squared_diff = 0.0\n        total_weight = 0.0\n\n        for group, mean in group_means.items():\n            weight = group_sizes[group]\n            weighted_sum_squared_diff += weight * ((mean - overall_mean) ** 2)\n            total_weight += weight\n\n        if total_weight &lt;= 0:\n            return 0.0\n\n        # Calculate raw between variance\n        raw_between_variance = weighted_sum_squared_diff / total_weight\n\n        # Adjust for within-group variance\n        process_variance = self.estimate_process_variance(data_by_group)\n\n        # Calculate average group size\n        avg_group_size = sum(group_sizes.values()) / len(group_sizes) if group_sizes else 0\n\n        # Adjust between variance by removing the expected contribution from process variance\n        adjusted_between_variance = max(0, raw_between_variance - (process_variance / avg_group_size))\n\n        return adjusted_between_variance\n\n    def limited_fluctuation_credibility(self, claim_count: int, full_credibility_standard: int = 1082) -&gt; float:\n        \"\"\"\n        Calculate credibility using the Limited Fluctuation (Classical) Credibility method.\n        Based on the formula Z = min(sqrt(n/n_full), 1) where n_full is the full credibility standard.\n\n        The default full_credibility_standard of 1082 corresponds to a 95% confidence level\n        with a 5% margin of error assuming a Poisson frequency process.\n\n        Args:\n            claim_count: Number of claims\n            full_credibility_standard: Number of claims needed for full credibility\n\n        Returns:\n            Credibility factor between 0 and 1\n        \"\"\"\n        if claim_count &lt;= 0 or full_credibility_standard &lt;= 0:\n            return 0.0\n\n        credibility = math.sqrt(claim_count / full_credibility_standard)\n        return min(credibility, 1.0)\n\n    def buhlmann_credibility(self, claim_count: int, expected_process_variance: float, \n                             variance_of_hypothetical_means: float) -&gt; float:\n        \"\"\"\n        Calculate credibility using the B\u00fchlmann Credibility method.\n        Based on the formula Z = n / (n + k) where k = EPV / VHM.\n\n        Args:\n            claim_count: Number of claims\n            expected_process_variance: Expected value of the process variance (EPV)\n            variance_of_hypothetical_means: Variance of the hypothetical means (VHM)\n\n        Returns:\n            Credibility factor between 0 and 1\n        \"\"\"\n        if claim_count &lt;= 0 or expected_process_variance &lt;= 0 or variance_of_hypothetical_means &lt;= 0:\n            return 0.0\n\n        k = expected_process_variance / variance_of_hypothetical_means\n        credibility = claim_count / (claim_count + k)\n\n        return min(max(credibility, 0.0), 1.0)\n\n    def buhlmann_straub_credibility(self, exposures: List[float], claim_counts: List[int], \n                                   expected_process_variance: float, \n                                   variance_of_hypothetical_means: float) -&gt; float:\n        \"\"\"\n        Calculate credibility using the B\u00fchlmann-Straub Credibility method.\n        This extends the B\u00fchlmann method to account for varying exposure sizes.\n\n        Args:\n            exposures: List of exposure values\n            claim_counts: List of claim counts corresponding to each exposure\n            expected_process_variance: Expected value of the process variance (EPV)\n            variance_of_hypothetical_means: Variance of the hypothetical means (VHM)\n\n        Returns:\n            Credibility factor between 0 and 1\n        \"\"\"\n        if not exposures or not claim_counts or len(exposures) != len(claim_counts):\n            return 0.0\n\n        if expected_process_variance &lt;= 0 or variance_of_hypothetical_means &lt;= 0:\n            return 0.0\n\n        total_exposure = sum(exposures)\n        if total_exposure &lt;= 0:\n            return 0.0\n\n        k = expected_process_variance / variance_of_hypothetical_means\n        credibility = total_exposure / (total_exposure + k)\n\n        return min(max(credibility, 0.0), 1.0)\n\n    def greatest_accuracy_credibility(self, data: List[float], collective_mean: float) -&gt; float:\n        \"\"\"\n        Calculate credibility using the Greatest Accuracy Credibility method.\n        This method aims to minimize the mean squared error.\n\n        Args:\n            data: List of observed values\n            collective_mean: The collective mean (a priori estimate)\n\n        Returns:\n            Credibility factor between 0 and 1\n        \"\"\"\n        if not data or collective_mean &lt;= 0:\n            return 0.0\n\n        # Calculate individual mean and variance\n        individual_mean = sum(data) / len(data)\n        if individual_mean &lt;= 0:\n            return 0.0\n\n        # Use the helper function to calculate variance\n        individual_variance = self.calculate_data_variance(data, method=\"population\")\n\n        # Calculate between variance (estimate of variance of hypothetical means)\n        between_variance = max(0, individual_variance - (collective_mean / len(data)))\n\n        # Calculate credibility\n        if between_variance &lt;= 0:\n            return 0.0\n\n        credibility = between_variance / (between_variance + (individual_variance / len(data)))\n\n        return min(max(credibility, 0.0), 1.0)\n\n    def bayesian_credibility(self, prior_mean: float, prior_variance: float, \n                            data: List[float], data_variance: float) -&gt; float:\n        \"\"\"\n        Calculate credibility using Bayesian Credibility approach.\n\n        Args:\n            prior_mean: Mean of the prior distribution\n            prior_variance: Variance of the prior distribution\n            data: List of observed values\n            data_variance: Variance of the data\n\n        Returns:\n            Credibility factor between 0 and 1\n        \"\"\"\n        if not data or prior_variance &lt;= 0 or data_variance &lt;= 0:\n            return 0.0\n\n        n = len(data)\n        if n &lt;= 0:\n            return 0.0\n\n        # Bayesian credibility formula\n        credibility = (n * prior_variance) / (n * prior_variance + data_variance)\n\n        return min(max(credibility, 0.0), 1.0)\n</code></pre>"},{"location":"models/#pyre.Models.AggregateFeatures.selections.CredibilityWeight.__init__","title":"<code>__init__(experience_data, exposure_data)</code>","text":"<p>Initialize the CredibilityWeight class with experience and exposure data.</p> <p>Parameters:</p> Name Type Description Default <code>experience_data</code> <code>ExperienceModelData</code> <p>Experience model data containing claims and exposures</p> required <code>exposure_data</code> <code>ExposureModelData</code> <p>Exposure model data containing exposures</p> required Source code in <code>src\\pyre\\Models\\AggregateFeatures\\selections.py</code> <pre><code>def __init__(self, experience_data: ExperienceModelData, exposure_data: ExposureModelData) -&gt; None:\n    \"\"\"\n    Initialize the CredibilityWeight class with experience and exposure data.\n\n    Args:\n        experience_data: Experience model data containing claims and exposures\n        exposure_data: Exposure model data containing exposures\n    \"\"\"\n    self.experience_data = experience_data\n    self.exposure_data = exposure_data\n</code></pre>"},{"location":"models/#pyre.Models.AggregateFeatures.selections.CredibilityWeight.bayesian_credibility","title":"<code>bayesian_credibility(prior_mean, prior_variance, data, data_variance)</code>","text":"<p>Calculate credibility using Bayesian Credibility approach.</p> <p>Parameters:</p> Name Type Description Default <code>prior_mean</code> <code>float</code> <p>Mean of the prior distribution</p> required <code>prior_variance</code> <code>float</code> <p>Variance of the prior distribution</p> required <code>data</code> <code>List[float]</code> <p>List of observed values</p> required <code>data_variance</code> <code>float</code> <p>Variance of the data</p> required <p>Returns:</p> Type Description <code>float</code> <p>Credibility factor between 0 and 1</p> Source code in <code>src\\pyre\\Models\\AggregateFeatures\\selections.py</code> <pre><code>def bayesian_credibility(self, prior_mean: float, prior_variance: float, \n                        data: List[float], data_variance: float) -&gt; float:\n    \"\"\"\n    Calculate credibility using Bayesian Credibility approach.\n\n    Args:\n        prior_mean: Mean of the prior distribution\n        prior_variance: Variance of the prior distribution\n        data: List of observed values\n        data_variance: Variance of the data\n\n    Returns:\n        Credibility factor between 0 and 1\n    \"\"\"\n    if not data or prior_variance &lt;= 0 or data_variance &lt;= 0:\n        return 0.0\n\n    n = len(data)\n    if n &lt;= 0:\n        return 0.0\n\n    # Bayesian credibility formula\n    credibility = (n * prior_variance) / (n * prior_variance + data_variance)\n\n    return min(max(credibility, 0.0), 1.0)\n</code></pre>"},{"location":"models/#pyre.Models.AggregateFeatures.selections.CredibilityWeight.buhlmann_credibility","title":"<code>buhlmann_credibility(claim_count, expected_process_variance, variance_of_hypothetical_means)</code>","text":"<p>Calculate credibility using the B\u00fchlmann Credibility method. Based on the formula Z = n / (n + k) where k = EPV / VHM.</p> <p>Parameters:</p> Name Type Description Default <code>claim_count</code> <code>int</code> <p>Number of claims</p> required <code>expected_process_variance</code> <code>float</code> <p>Expected value of the process variance (EPV)</p> required <code>variance_of_hypothetical_means</code> <code>float</code> <p>Variance of the hypothetical means (VHM)</p> required <p>Returns:</p> Type Description <code>float</code> <p>Credibility factor between 0 and 1</p> Source code in <code>src\\pyre\\Models\\AggregateFeatures\\selections.py</code> <pre><code>def buhlmann_credibility(self, claim_count: int, expected_process_variance: float, \n                         variance_of_hypothetical_means: float) -&gt; float:\n    \"\"\"\n    Calculate credibility using the B\u00fchlmann Credibility method.\n    Based on the formula Z = n / (n + k) where k = EPV / VHM.\n\n    Args:\n        claim_count: Number of claims\n        expected_process_variance: Expected value of the process variance (EPV)\n        variance_of_hypothetical_means: Variance of the hypothetical means (VHM)\n\n    Returns:\n        Credibility factor between 0 and 1\n    \"\"\"\n    if claim_count &lt;= 0 or expected_process_variance &lt;= 0 or variance_of_hypothetical_means &lt;= 0:\n        return 0.0\n\n    k = expected_process_variance / variance_of_hypothetical_means\n    credibility = claim_count / (claim_count + k)\n\n    return min(max(credibility, 0.0), 1.0)\n</code></pre>"},{"location":"models/#pyre.Models.AggregateFeatures.selections.CredibilityWeight.buhlmann_straub_credibility","title":"<code>buhlmann_straub_credibility(exposures, claim_counts, expected_process_variance, variance_of_hypothetical_means)</code>","text":"<p>Calculate credibility using the B\u00fchlmann-Straub Credibility method. This extends the B\u00fchlmann method to account for varying exposure sizes.</p> <p>Parameters:</p> Name Type Description Default <code>exposures</code> <code>List[float]</code> <p>List of exposure values</p> required <code>claim_counts</code> <code>List[int]</code> <p>List of claim counts corresponding to each exposure</p> required <code>expected_process_variance</code> <code>float</code> <p>Expected value of the process variance (EPV)</p> required <code>variance_of_hypothetical_means</code> <code>float</code> <p>Variance of the hypothetical means (VHM)</p> required <p>Returns:</p> Type Description <code>float</code> <p>Credibility factor between 0 and 1</p> Source code in <code>src\\pyre\\Models\\AggregateFeatures\\selections.py</code> <pre><code>def buhlmann_straub_credibility(self, exposures: List[float], claim_counts: List[int], \n                               expected_process_variance: float, \n                               variance_of_hypothetical_means: float) -&gt; float:\n    \"\"\"\n    Calculate credibility using the B\u00fchlmann-Straub Credibility method.\n    This extends the B\u00fchlmann method to account for varying exposure sizes.\n\n    Args:\n        exposures: List of exposure values\n        claim_counts: List of claim counts corresponding to each exposure\n        expected_process_variance: Expected value of the process variance (EPV)\n        variance_of_hypothetical_means: Variance of the hypothetical means (VHM)\n\n    Returns:\n        Credibility factor between 0 and 1\n    \"\"\"\n    if not exposures or not claim_counts or len(exposures) != len(claim_counts):\n        return 0.0\n\n    if expected_process_variance &lt;= 0 or variance_of_hypothetical_means &lt;= 0:\n        return 0.0\n\n    total_exposure = sum(exposures)\n    if total_exposure &lt;= 0:\n        return 0.0\n\n    k = expected_process_variance / variance_of_hypothetical_means\n    credibility = total_exposure / (total_exposure + k)\n\n    return min(max(credibility, 0.0), 1.0)\n</code></pre>"},{"location":"models/#pyre.Models.AggregateFeatures.selections.CredibilityWeight.calculate_data_variance","title":"<code>calculate_data_variance(data, method='sample')</code>","text":"<p>Calculate the variance of data using different methods.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>List[float]</code> <p>List of observed values</p> required <code>method</code> <code>str</code> <p>Method to use for variance calculation:    \"sample\" - standard sample variance    \"population\" - population variance    \"process\" - estimate of process variance for credibility</p> <code>'sample'</code> <p>Returns:</p> Type Description <code>float</code> <p>Variance of the data based on the specified method</p> Source code in <code>src\\pyre\\Models\\AggregateFeatures\\selections.py</code> <pre><code>def calculate_data_variance(self, data: List[float], method: str = \"sample\") -&gt; float:\n    \"\"\"\n    Calculate the variance of data using different methods.\n\n    Args:\n        data: List of observed values\n        method: Method to use for variance calculation:\n               \"sample\" - standard sample variance\n               \"population\" - population variance\n               \"process\" - estimate of process variance for credibility\n\n    Returns:\n        Variance of the data based on the specified method\n    \"\"\"\n    if not data or len(data) &lt; 2:\n        return 0.0\n\n    mean = sum(data) / len(data)\n\n    if method == \"sample\":\n        # Sample variance (unbiased estimator)\n        return sum((x - mean) ** 2 for x in data) / (len(data) - 1)\n    elif method == \"population\":\n        # Population variance\n        return sum((x - mean) ** 2 for x in data) / len(data)\n    elif method == \"process\":\n        # Process variance estimate for credibility calculations\n        # This is often the within-variance component\n        return sum((x - mean) ** 2 for x in data) / len(data)\n    else:\n        raise ValueError(f\"Invalid variance calculation method: {method}\")\n</code></pre>"},{"location":"models/#pyre.Models.AggregateFeatures.selections.CredibilityWeight.calculate_sample_variance","title":"<code>calculate_sample_variance(data)</code>","text":"<p>Calculate the sample variance of a list of data points.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>List[float]</code> <p>List of observed values</p> required <p>Returns:</p> Type Description <code>float</code> <p>Sample variance of the data</p> Source code in <code>src\\pyre\\Models\\AggregateFeatures\\selections.py</code> <pre><code>def calculate_sample_variance(self, data: List[float]) -&gt; float:\n    \"\"\"\n    Calculate the sample variance of a list of data points.\n\n    Args:\n        data: List of observed values\n\n    Returns:\n        Sample variance of the data\n    \"\"\"\n    if not data or len(data) &lt; 2:\n        return 0.0\n\n    mean = sum(data) / len(data)\n    variance = sum((x - mean) ** 2 for x in data) / (len(data) - 1)  # Using n-1 for sample variance\n\n    return variance\n</code></pre>"},{"location":"models/#pyre.Models.AggregateFeatures.selections.CredibilityWeight.estimate_process_variance","title":"<code>estimate_process_variance(data_by_group)</code>","text":"<p>Estimate the process variance (within variance) from grouped data. This is useful for B\u00fchlmann and B\u00fchlmann-Straub credibility methods.</p> <p>Parameters:</p> Name Type Description Default <code>data_by_group</code> <code>Dict[Any, List[float]]</code> <p>Dictionary mapping group identifiers to lists of observed values</p> required <p>Returns:</p> Type Description <code>float</code> <p>Estimated process variance</p> Source code in <code>src\\pyre\\Models\\AggregateFeatures\\selections.py</code> <pre><code>def estimate_process_variance(self, data_by_group: Dict[Any, List[float]]) -&gt; float:\n    \"\"\"\n    Estimate the process variance (within variance) from grouped data.\n    This is useful for B\u00fchlmann and B\u00fchlmann-Straub credibility methods.\n\n    Args:\n        data_by_group: Dictionary mapping group identifiers to lists of observed values\n\n    Returns:\n        Estimated process variance\n    \"\"\"\n    if not data_by_group:\n        return 0.0\n\n    total_variance = 0.0\n    total_weight = 0.0\n\n    for group, values in data_by_group.items():\n        if len(values) &lt; 2:\n            continue\n\n        # Calculate within-group variance\n        group_mean = sum(values) / len(values)\n        group_variance = sum((x - group_mean) ** 2 for x in values) / len(values)\n\n        # Weight by group size\n        weight = len(values)\n        total_variance += group_variance * weight\n        total_weight += weight\n\n    if total_weight &lt;= 0:\n        return 0.0\n\n    return total_variance / total_weight\n</code></pre>"},{"location":"models/#pyre.Models.AggregateFeatures.selections.CredibilityWeight.estimate_variance_of_hypothetical_means","title":"<code>estimate_variance_of_hypothetical_means(data_by_group)</code>","text":"<p>Estimate the variance of hypothetical means (between variance) from grouped data. This is useful for B\u00fchlmann and B\u00fchlmann-Straub credibility methods.</p> <p>Parameters:</p> Name Type Description Default <code>data_by_group</code> <code>Dict[Any, List[float]]</code> <p>Dictionary mapping group identifiers to lists of observed values</p> required <p>Returns:</p> Type Description <code>float</code> <p>Estimated variance of hypothetical means</p> Source code in <code>src\\pyre\\Models\\AggregateFeatures\\selections.py</code> <pre><code>def estimate_variance_of_hypothetical_means(self, data_by_group: Dict[Any, List[float]]) -&gt; float:\n    \"\"\"\n    Estimate the variance of hypothetical means (between variance) from grouped data.\n    This is useful for B\u00fchlmann and B\u00fchlmann-Straub credibility methods.\n\n    Args:\n        data_by_group: Dictionary mapping group identifiers to lists of observed values\n\n    Returns:\n        Estimated variance of hypothetical means\n    \"\"\"\n    if not data_by_group:\n        return 0.0\n\n    # Calculate overall mean\n    all_values = []\n    for values in data_by_group.values():\n        all_values.extend(values)\n\n    if not all_values:\n        return 0.0\n\n    overall_mean = sum(all_values) / len(all_values)\n\n    # Calculate group means\n    group_means = {}\n    group_sizes = {}\n\n    for group, values in data_by_group.items():\n        if not values:\n            continue\n\n        group_means[group] = sum(values) / len(values)\n        group_sizes[group] = len(values)\n\n    # Calculate variance of group means\n    weighted_sum_squared_diff = 0.0\n    total_weight = 0.0\n\n    for group, mean in group_means.items():\n        weight = group_sizes[group]\n        weighted_sum_squared_diff += weight * ((mean - overall_mean) ** 2)\n        total_weight += weight\n\n    if total_weight &lt;= 0:\n        return 0.0\n\n    # Calculate raw between variance\n    raw_between_variance = weighted_sum_squared_diff / total_weight\n\n    # Adjust for within-group variance\n    process_variance = self.estimate_process_variance(data_by_group)\n\n    # Calculate average group size\n    avg_group_size = sum(group_sizes.values()) / len(group_sizes) if group_sizes else 0\n\n    # Adjust between variance by removing the expected contribution from process variance\n    adjusted_between_variance = max(0, raw_between_variance - (process_variance / avg_group_size))\n\n    return adjusted_between_variance\n</code></pre>"},{"location":"models/#pyre.Models.AggregateFeatures.selections.CredibilityWeight.greatest_accuracy_credibility","title":"<code>greatest_accuracy_credibility(data, collective_mean)</code>","text":"<p>Calculate credibility using the Greatest Accuracy Credibility method. This method aims to minimize the mean squared error.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>List[float]</code> <p>List of observed values</p> required <code>collective_mean</code> <code>float</code> <p>The collective mean (a priori estimate)</p> required <p>Returns:</p> Type Description <code>float</code> <p>Credibility factor between 0 and 1</p> Source code in <code>src\\pyre\\Models\\AggregateFeatures\\selections.py</code> <pre><code>def greatest_accuracy_credibility(self, data: List[float], collective_mean: float) -&gt; float:\n    \"\"\"\n    Calculate credibility using the Greatest Accuracy Credibility method.\n    This method aims to minimize the mean squared error.\n\n    Args:\n        data: List of observed values\n        collective_mean: The collective mean (a priori estimate)\n\n    Returns:\n        Credibility factor between 0 and 1\n    \"\"\"\n    if not data or collective_mean &lt;= 0:\n        return 0.0\n\n    # Calculate individual mean and variance\n    individual_mean = sum(data) / len(data)\n    if individual_mean &lt;= 0:\n        return 0.0\n\n    # Use the helper function to calculate variance\n    individual_variance = self.calculate_data_variance(data, method=\"population\")\n\n    # Calculate between variance (estimate of variance of hypothetical means)\n    between_variance = max(0, individual_variance - (collective_mean / len(data)))\n\n    # Calculate credibility\n    if between_variance &lt;= 0:\n        return 0.0\n\n    credibility = between_variance / (between_variance + (individual_variance / len(data)))\n\n    return min(max(credibility, 0.0), 1.0)\n</code></pre>"},{"location":"models/#pyre.Models.AggregateFeatures.selections.CredibilityWeight.limited_fluctuation_credibility","title":"<code>limited_fluctuation_credibility(claim_count, full_credibility_standard=1082)</code>","text":"<p>Calculate credibility using the Limited Fluctuation (Classical) Credibility method. Based on the formula Z = min(sqrt(n/n_full), 1) where n_full is the full credibility standard.</p> <p>The default full_credibility_standard of 1082 corresponds to a 95% confidence level with a 5% margin of error assuming a Poisson frequency process.</p> <p>Parameters:</p> Name Type Description Default <code>claim_count</code> <code>int</code> <p>Number of claims</p> required <code>full_credibility_standard</code> <code>int</code> <p>Number of claims needed for full credibility</p> <code>1082</code> <p>Returns:</p> Type Description <code>float</code> <p>Credibility factor between 0 and 1</p> Source code in <code>src\\pyre\\Models\\AggregateFeatures\\selections.py</code> <pre><code>def limited_fluctuation_credibility(self, claim_count: int, full_credibility_standard: int = 1082) -&gt; float:\n    \"\"\"\n    Calculate credibility using the Limited Fluctuation (Classical) Credibility method.\n    Based on the formula Z = min(sqrt(n/n_full), 1) where n_full is the full credibility standard.\n\n    The default full_credibility_standard of 1082 corresponds to a 95% confidence level\n    with a 5% margin of error assuming a Poisson frequency process.\n\n    Args:\n        claim_count: Number of claims\n        full_credibility_standard: Number of claims needed for full credibility\n\n    Returns:\n        Credibility factor between 0 and 1\n    \"\"\"\n    if claim_count &lt;= 0 or full_credibility_standard &lt;= 0:\n        return 0.0\n\n    credibility = math.sqrt(claim_count / full_credibility_standard)\n    return min(credibility, 1.0)\n</code></pre>"},{"location":"models/#pyre.Models.AggregateFeatures.selections.Selections","title":"<code>Selections</code>","text":"Source code in <code>src\\pyre\\Models\\AggregateFeatures\\selections.py</code> <pre><code>class Selections:\n    def __init__(self, experience_data: ExperienceModelData, exposure_data: ExposureModelData, \n                 credibility_weight: Optional[CredibilityWeight] = None) -&gt; None:\n        \"\"\"\n        Initialize the Selections class with experience and exposure data.\n\n        Args:\n            experience_data: Experience model data containing claims and exposures\n            exposure_data: Exposure model data containing exposures\n            credibility_weight: Optional CredibilityWeight object for calculating weights\n        \"\"\"\n        self.experience_data = experience_data\n        self.exposure_data = exposure_data\n        self.credibility_weight = credibility_weight or CredibilityWeight(experience_data, exposure_data)\n        self._experience_weight = 0.5  # Default weight\n        self._exposure_weight = 0.5    # Default weight\n\n    def calculate_experience_weight(self, method: str = \"limited_fluctuation\", **kwargs) -&gt; float:\n        \"\"\"\n        Calculate the weight to assign to experience rating.\n\n        Args:\n            method: Credibility method to use (\"limited_fluctuation\", \"buhlmann\", \n                   \"buhlmann_straub\", \"greatest_accuracy\", or \"bayesian\")\n            **kwargs: Additional parameters for the credibility method\n\n        Returns:\n            Weight for experience rating between 0 and 1\n        \"\"\"\n        # Get claim count if not provided\n        if 'claim_count' not in kwargs and hasattr(self.experience_data, 'subject_contract_claims'):\n            kwargs['claim_count'] = len(self.experience_data.subject_contract_claims())\n\n        # Calculate credibility based on the selected method\n        if method == \"limited_fluctuation\":\n            weight = self.credibility_weight.limited_fluctuation_credibility(\n                kwargs.get('claim_count', 0), \n                kwargs.get('full_credibility_standard', 1082)\n            )\n        elif method == \"buhlmann\":\n            # Get claim count if not already provided\n            claim_count = kwargs.get('claim_count', 0)\n\n            # Get or calculate process variance and variance of hypothetical means\n            if 'data_by_group' in kwargs:\n                data_by_group = kwargs.get('data_by_group', {})\n\n                # Calculate variances if not provided\n                if 'expected_process_variance' not in kwargs:\n                    kwargs['expected_process_variance'] = self.credibility_weight.estimate_process_variance(data_by_group)\n\n                if 'variance_of_hypothetical_means' not in kwargs:\n                    kwargs['variance_of_hypothetical_means'] = self.credibility_weight.estimate_variance_of_hypothetical_means(data_by_group)\n\n            weight = self.credibility_weight.buhlmann_credibility(\n                claim_count,\n                kwargs.get('expected_process_variance', 1.0),\n                kwargs.get('variance_of_hypothetical_means', 0.1)\n            )\n        elif method == \"buhlmann_straub\":\n            # Get exposures and claim counts\n            exposures = kwargs.get('exposures', [])\n            claim_counts = kwargs.get('claim_counts', [])\n\n            # Get or calculate process variance and variance of hypothetical means\n            if 'data_by_group' in kwargs:\n                data_by_group = kwargs.get('data_by_group', {})\n\n                # Calculate variances if not provided\n                if 'expected_process_variance' not in kwargs:\n                    kwargs['expected_process_variance'] = self.credibility_weight.estimate_process_variance(data_by_group)\n\n                if 'variance_of_hypothetical_means' not in kwargs:\n                    kwargs['variance_of_hypothetical_means'] = self.credibility_weight.estimate_variance_of_hypothetical_means(data_by_group)\n\n            weight = self.credibility_weight.buhlmann_straub_credibility(\n                exposures,\n                claim_counts,\n                kwargs.get('expected_process_variance', 1.0),\n                kwargs.get('variance_of_hypothetical_means', 0.1)\n            )\n        elif method == \"greatest_accuracy\":\n            # Get loss data if not provided\n            if 'data' not in kwargs and hasattr(self.experience_data, 'subject_contract_claims'):\n                kwargs['data'] = [claim.amount for claim in self.experience_data.subject_contract_claims()]\n\n            # Get data for easier access\n            data = kwargs.get('data', [])\n\n            weight = self.credibility_weight.greatest_accuracy_credibility(\n                data,\n                kwargs.get('collective_mean', 1.0)\n            )\n        elif method == \"bayesian\":\n            # Get loss data if not provided\n            if 'data' not in kwargs and hasattr(self.experience_data, 'subject_contract_claims'):\n                kwargs['data'] = [claim.amount for claim in self.experience_data.subject_contract_claims()]\n\n            # Calculate data variance if not provided\n            data = kwargs.get('data', [])\n            if 'data_variance' not in kwargs and data:\n                kwargs['data_variance'] = self.credibility_weight.calculate_data_variance(data, method=\"sample\")\n\n            weight = self.credibility_weight.bayesian_credibility(\n                kwargs.get('prior_mean', 1.0),\n                kwargs.get('prior_variance', 0.1),\n                data,\n                kwargs.get('data_variance', 1.0)\n            )\n        else:\n            raise ValueError(f\"Invalid credibility method: {method}\")\n\n        self._experience_weight = weight\n        self._exposure_weight = 1.0 - weight\n\n        return weight\n\n    def exposure_weight(self) -&gt; float:\n        \"\"\"\n        Get the weight to assign to exposure rating.\n\n        Returns:\n            Weight for exposure rating between 0 and 1\n        \"\"\"\n        return self._exposure_weight\n\n    def unlimited_selection(self, experience_result: float, exposure_result: float) -&gt; float:\n        \"\"\"\n        Selects the unlimited option for the subject contract by combining\n        experience and exposure results based on their weights.\n\n        Args:\n            experience_result: Result from experience rating method\n            exposure_result: Result from exposure rating method\n\n        Returns:\n            Weighted average of experience and exposure results\n        \"\"\"\n        return (experience_result * self._experience_weight + \n                exposure_result * self._exposure_weight)\n\n    def make_selection(self, experience_result: float, exposure_result: float, \n                      method: str = \"limited_fluctuation\", **kwargs) -&gt; float:\n        \"\"\"\n        Make a selection by calculating weights and combining results.\n\n        Args:\n            experience_result: Result from experience rating method\n            exposure_result: Result from exposure rating method\n            method: Credibility method to use\n            **kwargs: Additional parameters for the credibility method\n\n        Returns:\n            Selected result based on weighted average\n        \"\"\"\n        # Calculate weights\n        self.calculate_experience_weight(method, **kwargs)\n\n        # Return weighted average\n        return self.unlimited_selection(experience_result, exposure_result)\n</code></pre>"},{"location":"models/#pyre.Models.AggregateFeatures.selections.Selections.__init__","title":"<code>__init__(experience_data, exposure_data, credibility_weight=None)</code>","text":"<p>Initialize the Selections class with experience and exposure data.</p> <p>Parameters:</p> Name Type Description Default <code>experience_data</code> <code>ExperienceModelData</code> <p>Experience model data containing claims and exposures</p> required <code>exposure_data</code> <code>ExposureModelData</code> <p>Exposure model data containing exposures</p> required <code>credibility_weight</code> <code>Optional[CredibilityWeight]</code> <p>Optional CredibilityWeight object for calculating weights</p> <code>None</code> Source code in <code>src\\pyre\\Models\\AggregateFeatures\\selections.py</code> <pre><code>def __init__(self, experience_data: ExperienceModelData, exposure_data: ExposureModelData, \n             credibility_weight: Optional[CredibilityWeight] = None) -&gt; None:\n    \"\"\"\n    Initialize the Selections class with experience and exposure data.\n\n    Args:\n        experience_data: Experience model data containing claims and exposures\n        exposure_data: Exposure model data containing exposures\n        credibility_weight: Optional CredibilityWeight object for calculating weights\n    \"\"\"\n    self.experience_data = experience_data\n    self.exposure_data = exposure_data\n    self.credibility_weight = credibility_weight or CredibilityWeight(experience_data, exposure_data)\n    self._experience_weight = 0.5  # Default weight\n    self._exposure_weight = 0.5    # Default weight\n</code></pre>"},{"location":"models/#pyre.Models.AggregateFeatures.selections.Selections.calculate_experience_weight","title":"<code>calculate_experience_weight(method='limited_fluctuation', **kwargs)</code>","text":"<p>Calculate the weight to assign to experience rating.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>Credibility method to use (\"limited_fluctuation\", \"buhlmann\",     \"buhlmann_straub\", \"greatest_accuracy\", or \"bayesian\")</p> <code>'limited_fluctuation'</code> <code>**kwargs</code> <p>Additional parameters for the credibility method</p> <code>{}</code> <p>Returns:</p> Type Description <code>float</code> <p>Weight for experience rating between 0 and 1</p> Source code in <code>src\\pyre\\Models\\AggregateFeatures\\selections.py</code> <pre><code>def calculate_experience_weight(self, method: str = \"limited_fluctuation\", **kwargs) -&gt; float:\n    \"\"\"\n    Calculate the weight to assign to experience rating.\n\n    Args:\n        method: Credibility method to use (\"limited_fluctuation\", \"buhlmann\", \n               \"buhlmann_straub\", \"greatest_accuracy\", or \"bayesian\")\n        **kwargs: Additional parameters for the credibility method\n\n    Returns:\n        Weight for experience rating between 0 and 1\n    \"\"\"\n    # Get claim count if not provided\n    if 'claim_count' not in kwargs and hasattr(self.experience_data, 'subject_contract_claims'):\n        kwargs['claim_count'] = len(self.experience_data.subject_contract_claims())\n\n    # Calculate credibility based on the selected method\n    if method == \"limited_fluctuation\":\n        weight = self.credibility_weight.limited_fluctuation_credibility(\n            kwargs.get('claim_count', 0), \n            kwargs.get('full_credibility_standard', 1082)\n        )\n    elif method == \"buhlmann\":\n        # Get claim count if not already provided\n        claim_count = kwargs.get('claim_count', 0)\n\n        # Get or calculate process variance and variance of hypothetical means\n        if 'data_by_group' in kwargs:\n            data_by_group = kwargs.get('data_by_group', {})\n\n            # Calculate variances if not provided\n            if 'expected_process_variance' not in kwargs:\n                kwargs['expected_process_variance'] = self.credibility_weight.estimate_process_variance(data_by_group)\n\n            if 'variance_of_hypothetical_means' not in kwargs:\n                kwargs['variance_of_hypothetical_means'] = self.credibility_weight.estimate_variance_of_hypothetical_means(data_by_group)\n\n        weight = self.credibility_weight.buhlmann_credibility(\n            claim_count,\n            kwargs.get('expected_process_variance', 1.0),\n            kwargs.get('variance_of_hypothetical_means', 0.1)\n        )\n    elif method == \"buhlmann_straub\":\n        # Get exposures and claim counts\n        exposures = kwargs.get('exposures', [])\n        claim_counts = kwargs.get('claim_counts', [])\n\n        # Get or calculate process variance and variance of hypothetical means\n        if 'data_by_group' in kwargs:\n            data_by_group = kwargs.get('data_by_group', {})\n\n            # Calculate variances if not provided\n            if 'expected_process_variance' not in kwargs:\n                kwargs['expected_process_variance'] = self.credibility_weight.estimate_process_variance(data_by_group)\n\n            if 'variance_of_hypothetical_means' not in kwargs:\n                kwargs['variance_of_hypothetical_means'] = self.credibility_weight.estimate_variance_of_hypothetical_means(data_by_group)\n\n        weight = self.credibility_weight.buhlmann_straub_credibility(\n            exposures,\n            claim_counts,\n            kwargs.get('expected_process_variance', 1.0),\n            kwargs.get('variance_of_hypothetical_means', 0.1)\n        )\n    elif method == \"greatest_accuracy\":\n        # Get loss data if not provided\n        if 'data' not in kwargs and hasattr(self.experience_data, 'subject_contract_claims'):\n            kwargs['data'] = [claim.amount for claim in self.experience_data.subject_contract_claims()]\n\n        # Get data for easier access\n        data = kwargs.get('data', [])\n\n        weight = self.credibility_weight.greatest_accuracy_credibility(\n            data,\n            kwargs.get('collective_mean', 1.0)\n        )\n    elif method == \"bayesian\":\n        # Get loss data if not provided\n        if 'data' not in kwargs and hasattr(self.experience_data, 'subject_contract_claims'):\n            kwargs['data'] = [claim.amount for claim in self.experience_data.subject_contract_claims()]\n\n        # Calculate data variance if not provided\n        data = kwargs.get('data', [])\n        if 'data_variance' not in kwargs and data:\n            kwargs['data_variance'] = self.credibility_weight.calculate_data_variance(data, method=\"sample\")\n\n        weight = self.credibility_weight.bayesian_credibility(\n            kwargs.get('prior_mean', 1.0),\n            kwargs.get('prior_variance', 0.1),\n            data,\n            kwargs.get('data_variance', 1.0)\n        )\n    else:\n        raise ValueError(f\"Invalid credibility method: {method}\")\n\n    self._experience_weight = weight\n    self._exposure_weight = 1.0 - weight\n\n    return weight\n</code></pre>"},{"location":"models/#pyre.Models.AggregateFeatures.selections.Selections.exposure_weight","title":"<code>exposure_weight()</code>","text":"<p>Get the weight to assign to exposure rating.</p> <p>Returns:</p> Type Description <code>float</code> <p>Weight for exposure rating between 0 and 1</p> Source code in <code>src\\pyre\\Models\\AggregateFeatures\\selections.py</code> <pre><code>def exposure_weight(self) -&gt; float:\n    \"\"\"\n    Get the weight to assign to exposure rating.\n\n    Returns:\n        Weight for exposure rating between 0 and 1\n    \"\"\"\n    return self._exposure_weight\n</code></pre>"},{"location":"models/#pyre.Models.AggregateFeatures.selections.Selections.make_selection","title":"<code>make_selection(experience_result, exposure_result, method='limited_fluctuation', **kwargs)</code>","text":"<p>Make a selection by calculating weights and combining results.</p> <p>Parameters:</p> Name Type Description Default <code>experience_result</code> <code>float</code> <p>Result from experience rating method</p> required <code>exposure_result</code> <code>float</code> <p>Result from exposure rating method</p> required <code>method</code> <code>str</code> <p>Credibility method to use</p> <code>'limited_fluctuation'</code> <code>**kwargs</code> <p>Additional parameters for the credibility method</p> <code>{}</code> <p>Returns:</p> Type Description <code>float</code> <p>Selected result based on weighted average</p> Source code in <code>src\\pyre\\Models\\AggregateFeatures\\selections.py</code> <pre><code>def make_selection(self, experience_result: float, exposure_result: float, \n                  method: str = \"limited_fluctuation\", **kwargs) -&gt; float:\n    \"\"\"\n    Make a selection by calculating weights and combining results.\n\n    Args:\n        experience_result: Result from experience rating method\n        exposure_result: Result from exposure rating method\n        method: Credibility method to use\n        **kwargs: Additional parameters for the credibility method\n\n    Returns:\n        Selected result based on weighted average\n    \"\"\"\n    # Calculate weights\n    self.calculate_experience_weight(method, **kwargs)\n\n    # Return weighted average\n    return self.unlimited_selection(experience_result, exposure_result)\n</code></pre>"},{"location":"models/#pyre.Models.AggregateFeatures.selections.Selections.unlimited_selection","title":"<code>unlimited_selection(experience_result, exposure_result)</code>","text":"<p>Selects the unlimited option for the subject contract by combining experience and exposure results based on their weights.</p> <p>Parameters:</p> Name Type Description Default <code>experience_result</code> <code>float</code> <p>Result from experience rating method</p> required <code>exposure_result</code> <code>float</code> <p>Result from exposure rating method</p> required <p>Returns:</p> Type Description <code>float</code> <p>Weighted average of experience and exposure results</p> Source code in <code>src\\pyre\\Models\\AggregateFeatures\\selections.py</code> <pre><code>def unlimited_selection(self, experience_result: float, exposure_result: float) -&gt; float:\n    \"\"\"\n    Selects the unlimited option for the subject contract by combining\n    experience and exposure results based on their weights.\n\n    Args:\n        experience_result: Result from experience rating method\n        exposure_result: Result from exposure rating method\n\n    Returns:\n        Weighted average of experience and exposure results\n    \"\"\"\n    return (experience_result * self._experience_weight + \n            exposure_result * self._exposure_weight)\n</code></pre>"},{"location":"models/#pyre.Models.trending.Trending","title":"<code>Trending</code>","text":"<p>A class for trending insurance data (claims and exposures) to a common base year.</p> <p>This class provides methods to apply trend factors to claims and exposures, adjusting their values to account for inflation or other time-based changes.</p> <p>Attributes:</p> Name Type Description <code>exposure_trend_factors</code> <code>Dict[int, float]</code> <p>Mapping of year to annual trend factor for exposures (e.g., {2020: 1.02, 2021: 1.03, ...}).</p> <code>claim_trend_factors</code> <code>Dict[int, float]</code> <p>Mapping of year to annual trend factor for claims (e.g., {2020: 1.02, 2021: 1.03, ...}).</p> <code>base_year</code> <code>int</code> <p>The year to which all data will be trended.</p> Source code in <code>src\\pyre\\Models\\trending.py</code> <pre><code>class Trending:\n    \"\"\"\n    A class for trending insurance data (claims and exposures) to a common base year.\n\n    This class provides methods to apply trend factors to claims and exposures,\n    adjusting their values to account for inflation or other time-based changes.\n\n    Attributes:\n        exposure_trend_factors (Dict[int, float]): Mapping of year to annual trend factor for exposures\n            (e.g., {2020: 1.02, 2021: 1.03, ...}).\n        claim_trend_factors (Dict[int, float]): Mapping of year to annual trend factor for claims\n            (e.g., {2020: 1.02, 2021: 1.03, ...}).\n        base_year (int): The year to which all data will be trended.\n    \"\"\"\n\n    def __init__(self, exposure_trend_factors: Dict[int, float], claim_trend_factors: Dict[int, float] = None, trend_factors: Dict[int, float] = None, base_year: int = None):\n        \"\"\"\n        Initialize the Trending class with trend factors and a base year.\n\n        Args:\n            exposure_trend_factors (Dict[int, float]): Mapping of year to annual trend factor for exposures\n                (e.g., {2020: 1.02, 2021: 1.03, ...}).\n            claim_trend_factors (Dict[int, float], optional): Mapping of year to annual trend factor for claims.\n                If None, exposure_trend_factors will be used for claims as well.\n            trend_factors (Dict[int, float], optional): For backward compatibility. If provided, both\n                exposure_trend_factors and claim_trend_factors will be set to this value.\n            base_year (int): The year to which all data will be trended.\n        \"\"\"\n        self.exposure_trend_factors = exposure_trend_factors\n        self.claim_trend_factors = claim_trend_factors\n        self.base_year = base_year\n        self._validate_inputs()\n\n    def _validate_inputs(self) -&gt; None:\n        \"\"\"\n        Validate the trend factors and base year.\n\n        Raises:\n            ValueError: If trend factors dictionaries are empty or base_year is not an integer.\n        \"\"\"\n        if not self.exposure_trend_factors:\n            raise ValueError(\"Exposure trend factors dictionary cannot be empty\")\n        if not self.claim_trend_factors:\n            raise ValueError(\"Claim trend factors dictionary cannot be empty\")\n        if not isinstance(self.base_year, int):\n            raise ValueError(\"Base year must be an integer\")\n\n    def calculate_trend_factor(self, origin_year: int, for_claims: bool = False) -&gt; float:\n        \"\"\"\n        Calculate the trend factor between the origin year and the base year.\n\n        Args:\n            origin_year (int): The year from which to trend.\n            for_claims (bool, optional): If True, use claim trend factors. If False, use exposure trend factors.\n                Defaults to False.\n\n        Returns:\n            float: The calculated trend factor.\n        \"\"\"\n        # Select the appropriate trend factors based on the for_claims parameter\n        trend_factors = self.claim_trend_factors if for_claims else self.exposure_trend_factors\n\n        if origin_year == self.base_year:\n            return 1.0\n        elif origin_year &lt; self.base_year:\n            factor = 1.0\n            for year in range(origin_year, self.base_year):\n                factor *= trend_factors.get(year, 1.0)\n            return factor\n        else:\n            factor = 1.0\n            for year in range(self.base_year, origin_year):\n                factor /= trend_factors.get(year, 1.0)\n            return factor\n\n    def trend_exposures(self, exposures: Exposures) -&gt; Exposures:\n        \"\"\"\n        Apply trend factors to a collection of exposures.\n\n        Args:\n            exposures (Exposures): The original Exposures object.\n\n        Returns:\n            Exposures: A new Exposures object with trended values.\n        \"\"\"\n        trended_exposures = []\n\n        for exposure in exposures:\n            # Get the modelling year and exposure value\n            origin_year = exposure.modelling_year()\n\n            # Create a new exposure with trended values\n            # Use exposure trend factors (for_claims=False is the default)\n            trend_factor = self.calculate_trend_factor(origin_year, for_claims=False)\n\n            # Get the original exposure values\n            original_values = exposure.exposure_values()\n            trended_value = original_values.exposure_value * trend_factor\n\n            # Create new ExposureValues with the trended value\n            new_values = ExposureValues(\n                exposure_value=trended_value,\n                attachment_point=original_values.attachment_point,\n                limit=original_values.limit\n            )\n\n            # Create a new Exposure with the same metadata but trended values\n            new_exposure = Exposure(\n                exposure_meta=exposure.exposure_meta,\n                exposure_values=new_values\n            )\n\n            trended_exposures.append(new_exposure)\n\n        return Exposures(trended_exposures)\n\n    def get_trend_factors(self) -&gt; Dict[str, Dict[int, float]]:\n        \"\"\"\n        Get the trend factors from this Trending instance.\n\n        Returns:\n            Dict[str, Dict[int, float]]: A dictionary with keys 'exposure' and 'claim', each mapping to\n                their respective trend factors dictionary.\n        \"\"\"\n        return {\n            'exposure': self.exposure_trend_factors,\n            'claim': self.claim_trend_factors\n        }\n\n    def trend_claims(self, claims: Claims) -&gt; Claims:\n        \"\"\"\n        Apply trend factors to a collection of claims.\n\n        Args:\n            claims (Claims): The original Claims object.\n\n        Returns:\n            Claims: A new Claims object with trended ClaimDevelopmentHistory for each claim.\n        \"\"\"\n        trended_claims = []\n\n        for claim in claims.claims:\n            # Get the modelling year for trending\n            origin_year = claim.claims_meta_data.modelling_year\n            # Use claim trend factors (for_claims=True)\n            trend_factor = self.calculate_trend_factor(origin_year, for_claims=True)\n\n            # Get the development history\n            dev_hist = claim.uncapped_claim_development_history\n\n            # Trend all paid and incurred values in the development history\n            trended_paid = [x * trend_factor for x in dev_hist.cumulative_dev_paid]\n            trended_incurred = [x * trend_factor for x in dev_hist.cumulative_dev_incurred]\n\n            # Create a new development history with trended values\n            trended_dev_hist = ClaimDevelopmentHistory(\n                development_months=dev_hist.development_months,\n                cumulative_dev_paid=trended_paid,\n                cumulative_dev_incurred=trended_incurred,\n            )\n\n            # Create a new Claim with the same metadata and trended development history\n            trended_claim = Claim(\n                claims_meta_data=claim.claims_meta_data, \n                claims_development_history=trended_dev_hist\n            )\n\n            trended_claims.append(trended_claim)\n\n        return Claims(trended_claims)\n</code></pre>"},{"location":"models/#pyre.Models.trending.Trending.__init__","title":"<code>__init__(exposure_trend_factors, claim_trend_factors=None, trend_factors=None, base_year=None)</code>","text":"<p>Initialize the Trending class with trend factors and a base year.</p> <p>Parameters:</p> Name Type Description Default <code>exposure_trend_factors</code> <code>Dict[int, float]</code> <p>Mapping of year to annual trend factor for exposures (e.g., {2020: 1.02, 2021: 1.03, ...}).</p> required <code>claim_trend_factors</code> <code>Dict[int, float]</code> <p>Mapping of year to annual trend factor for claims. If None, exposure_trend_factors will be used for claims as well.</p> <code>None</code> <code>trend_factors</code> <code>Dict[int, float]</code> <p>For backward compatibility. If provided, both exposure_trend_factors and claim_trend_factors will be set to this value.</p> <code>None</code> <code>base_year</code> <code>int</code> <p>The year to which all data will be trended.</p> <code>None</code> Source code in <code>src\\pyre\\Models\\trending.py</code> <pre><code>def __init__(self, exposure_trend_factors: Dict[int, float], claim_trend_factors: Dict[int, float] = None, trend_factors: Dict[int, float] = None, base_year: int = None):\n    \"\"\"\n    Initialize the Trending class with trend factors and a base year.\n\n    Args:\n        exposure_trend_factors (Dict[int, float]): Mapping of year to annual trend factor for exposures\n            (e.g., {2020: 1.02, 2021: 1.03, ...}).\n        claim_trend_factors (Dict[int, float], optional): Mapping of year to annual trend factor for claims.\n            If None, exposure_trend_factors will be used for claims as well.\n        trend_factors (Dict[int, float], optional): For backward compatibility. If provided, both\n            exposure_trend_factors and claim_trend_factors will be set to this value.\n        base_year (int): The year to which all data will be trended.\n    \"\"\"\n    self.exposure_trend_factors = exposure_trend_factors\n    self.claim_trend_factors = claim_trend_factors\n    self.base_year = base_year\n    self._validate_inputs()\n</code></pre>"},{"location":"models/#pyre.Models.trending.Trending.calculate_trend_factor","title":"<code>calculate_trend_factor(origin_year, for_claims=False)</code>","text":"<p>Calculate the trend factor between the origin year and the base year.</p> <p>Parameters:</p> Name Type Description Default <code>origin_year</code> <code>int</code> <p>The year from which to trend.</p> required <code>for_claims</code> <code>bool</code> <p>If True, use claim trend factors. If False, use exposure trend factors. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The calculated trend factor.</p> Source code in <code>src\\pyre\\Models\\trending.py</code> <pre><code>def calculate_trend_factor(self, origin_year: int, for_claims: bool = False) -&gt; float:\n    \"\"\"\n    Calculate the trend factor between the origin year and the base year.\n\n    Args:\n        origin_year (int): The year from which to trend.\n        for_claims (bool, optional): If True, use claim trend factors. If False, use exposure trend factors.\n            Defaults to False.\n\n    Returns:\n        float: The calculated trend factor.\n    \"\"\"\n    # Select the appropriate trend factors based on the for_claims parameter\n    trend_factors = self.claim_trend_factors if for_claims else self.exposure_trend_factors\n\n    if origin_year == self.base_year:\n        return 1.0\n    elif origin_year &lt; self.base_year:\n        factor = 1.0\n        for year in range(origin_year, self.base_year):\n            factor *= trend_factors.get(year, 1.0)\n        return factor\n    else:\n        factor = 1.0\n        for year in range(self.base_year, origin_year):\n            factor /= trend_factors.get(year, 1.0)\n        return factor\n</code></pre>"},{"location":"models/#pyre.Models.trending.Trending.get_trend_factors","title":"<code>get_trend_factors()</code>","text":"<p>Get the trend factors from this Trending instance.</p> <p>Returns:</p> Type Description <code>Dict[str, Dict[int, float]]</code> <p>Dict[str, Dict[int, float]]: A dictionary with keys 'exposure' and 'claim', each mapping to their respective trend factors dictionary.</p> Source code in <code>src\\pyre\\Models\\trending.py</code> <pre><code>def get_trend_factors(self) -&gt; Dict[str, Dict[int, float]]:\n    \"\"\"\n    Get the trend factors from this Trending instance.\n\n    Returns:\n        Dict[str, Dict[int, float]]: A dictionary with keys 'exposure' and 'claim', each mapping to\n            their respective trend factors dictionary.\n    \"\"\"\n    return {\n        'exposure': self.exposure_trend_factors,\n        'claim': self.claim_trend_factors\n    }\n</code></pre>"},{"location":"models/#pyre.Models.trending.Trending.trend_claims","title":"<code>trend_claims(claims)</code>","text":"<p>Apply trend factors to a collection of claims.</p> <p>Parameters:</p> Name Type Description Default <code>claims</code> <code>Claims</code> <p>The original Claims object.</p> required <p>Returns:</p> Name Type Description <code>Claims</code> <code>Claims</code> <p>A new Claims object with trended ClaimDevelopmentHistory for each claim.</p> Source code in <code>src\\pyre\\Models\\trending.py</code> <pre><code>def trend_claims(self, claims: Claims) -&gt; Claims:\n    \"\"\"\n    Apply trend factors to a collection of claims.\n\n    Args:\n        claims (Claims): The original Claims object.\n\n    Returns:\n        Claims: A new Claims object with trended ClaimDevelopmentHistory for each claim.\n    \"\"\"\n    trended_claims = []\n\n    for claim in claims.claims:\n        # Get the modelling year for trending\n        origin_year = claim.claims_meta_data.modelling_year\n        # Use claim trend factors (for_claims=True)\n        trend_factor = self.calculate_trend_factor(origin_year, for_claims=True)\n\n        # Get the development history\n        dev_hist = claim.uncapped_claim_development_history\n\n        # Trend all paid and incurred values in the development history\n        trended_paid = [x * trend_factor for x in dev_hist.cumulative_dev_paid]\n        trended_incurred = [x * trend_factor for x in dev_hist.cumulative_dev_incurred]\n\n        # Create a new development history with trended values\n        trended_dev_hist = ClaimDevelopmentHistory(\n            development_months=dev_hist.development_months,\n            cumulative_dev_paid=trended_paid,\n            cumulative_dev_incurred=trended_incurred,\n        )\n\n        # Create a new Claim with the same metadata and trended development history\n        trended_claim = Claim(\n            claims_meta_data=claim.claims_meta_data, \n            claims_development_history=trended_dev_hist\n        )\n\n        trended_claims.append(trended_claim)\n\n    return Claims(trended_claims)\n</code></pre>"},{"location":"models/#pyre.Models.trending.Trending.trend_exposures","title":"<code>trend_exposures(exposures)</code>","text":"<p>Apply trend factors to a collection of exposures.</p> <p>Parameters:</p> Name Type Description Default <code>exposures</code> <code>Exposures</code> <p>The original Exposures object.</p> required <p>Returns:</p> Name Type Description <code>Exposures</code> <code>Exposures</code> <p>A new Exposures object with trended values.</p> Source code in <code>src\\pyre\\Models\\trending.py</code> <pre><code>def trend_exposures(self, exposures: Exposures) -&gt; Exposures:\n    \"\"\"\n    Apply trend factors to a collection of exposures.\n\n    Args:\n        exposures (Exposures): The original Exposures object.\n\n    Returns:\n        Exposures: A new Exposures object with trended values.\n    \"\"\"\n    trended_exposures = []\n\n    for exposure in exposures:\n        # Get the modelling year and exposure value\n        origin_year = exposure.modelling_year()\n\n        # Create a new exposure with trended values\n        # Use exposure trend factors (for_claims=False is the default)\n        trend_factor = self.calculate_trend_factor(origin_year, for_claims=False)\n\n        # Get the original exposure values\n        original_values = exposure.exposure_values()\n        trended_value = original_values.exposure_value * trend_factor\n\n        # Create new ExposureValues with the trended value\n        new_values = ExposureValues(\n            exposure_value=trended_value,\n            attachment_point=original_values.attachment_point,\n            limit=original_values.limit\n        )\n\n        # Create a new Exposure with the same metadata but trended values\n        new_exposure = Exposure(\n            exposure_meta=exposure.exposure_meta,\n            exposure_values=new_values\n        )\n\n        trended_exposures.append(new_exposure)\n\n    return Exposures(trended_exposures)\n</code></pre>"},{"location":"models/#pyre.Models.trending.calculate_trend_factor","title":"<code>calculate_trend_factor(origin_year, base_year, trend_factors, for_claims=False)</code>","text":"<p>Calculate the trend factor between the origin year and the base year.</p> <p>Parameters:</p> Name Type Description Default <code>origin_year</code> <code>int</code> <p>The year from which to trend.</p> required <code>base_year</code> <code>int</code> <p>The year to which to trend.</p> required <code>trend_factors</code> <code>Dict[int, float]</code> <p>Mapping of year to annual trend factor.</p> required <code>for_claims</code> <code>bool</code> <p>If True, use as claim trend factors. If False, use as exposure trend factors. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The calculated trend factor.</p> Source code in <code>src\\pyre\\Models\\trending.py</code> <pre><code>def calculate_trend_factor(origin_year: int, base_year: int, trend_factors: Dict[int, float], for_claims: bool = False) -&gt; float:\n    \"\"\"\n    Calculate the trend factor between the origin year and the base year.\n\n    Args:\n        origin_year (int): The year from which to trend.\n        base_year (int): The year to which to trend.\n        trend_factors (Dict[int, float]): Mapping of year to annual trend factor.\n        for_claims (bool, optional): If True, use as claim trend factors. If False, use as exposure trend factors.\n            Defaults to False.\n\n    Returns:\n        float: The calculated trend factor.\n    \"\"\"\n    if for_claims:\n        trending = Trending(exposure_trend_factors=trend_factors, claim_trend_factors=trend_factors, base_year=base_year)\n        return trending.calculate_trend_factor(origin_year, for_claims=True)\n    else:\n        trending = Trending(exposure_trend_factors=trend_factors, claim_trend_factors=trend_factors, base_year=base_year)\n        return trending.calculate_trend_factor(origin_year, for_claims=False)\n</code></pre>"},{"location":"models/#pyre.Models.trending.get_trend_factors","title":"<code>get_trend_factors(trending_instance)</code>","text":"<p>Get the trend factors from a Trending instance.</p> <p>Parameters:</p> Name Type Description Default <code>trending_instance</code> <code>Trending</code> <p>The Trending instance to get trend factors from.</p> required <p>Returns:</p> Type Description <code>Dict[str, Dict[int, float]]</code> <p>Dict[str, Dict[int, float]]: A dictionary with keys 'exposure' and 'claim', each mapping to their respective trend factors dictionary.</p> Source code in <code>src\\pyre\\Models\\trending.py</code> <pre><code>def get_trend_factors(trending_instance: Trending) -&gt; Dict[str, Dict[int, float]]:\n    \"\"\"\n    Get the trend factors from a Trending instance.\n\n    Args:\n        trending_instance (Trending): The Trending instance to get trend factors from.\n\n    Returns:\n        Dict[str, Dict[int, float]]: A dictionary with keys 'exposure' and 'claim', each mapping to\n            their respective trend factors dictionary.\n    \"\"\"\n    return {\n        'exposure': trending_instance.exposure_trend_factors,\n        'claim': trending_instance.claim_trend_factors\n    }\n</code></pre>"},{"location":"models/#pyre.Models.trending.trend_claims","title":"<code>trend_claims(claims, trend_factors, base_year)</code>","text":"<p>Apply trend factors to a collection of claims.</p> <p>Parameters:</p> Name Type Description Default <code>claims</code> <code>Claims</code> <p>The original Claims object.</p> required <code>trend_factors</code> <code>Dict[int, float]</code> <p>Mapping of year to annual trend factor.</p> required <code>base_year</code> <code>int</code> <p>The year to which all claims will be trended.</p> required <p>Returns:</p> Name Type Description <code>Claims</code> <code>Claims</code> <p>A new Claims object with trended ClaimDevelopmentHistory for each claim.</p> Source code in <code>src\\pyre\\Models\\trending.py</code> <pre><code>def trend_claims(claims: Claims, trend_factors: Dict[int, float], base_year: int) -&gt; Claims:\n    \"\"\"\n    Apply trend factors to a collection of claims.\n\n    Args:\n        claims (Claims): The original Claims object.\n        trend_factors (Dict[int, float]): Mapping of year to annual trend factor.\n        base_year (int): The year to which all claims will be trended.\n\n    Returns:\n        Claims: A new Claims object with trended ClaimDevelopmentHistory for each claim.\n    \"\"\"\n    trending = Trending(exposure_trend_factors=trend_factors, claim_trend_factors=trend_factors, base_year=base_year)\n    return trending.trend_claims(claims)\n</code></pre>"},{"location":"models/#pyre.Models.trending.trend_exposures","title":"<code>trend_exposures(exposures, trend_factors, base_year)</code>","text":"<p>Apply trend factors to a collection of exposures.</p> <p>Parameters:</p> Name Type Description Default <code>exposures</code> <code>Exposures</code> <p>The original Exposures object.</p> required <code>trend_factors</code> <code>Dict[int, float]</code> <p>Mapping of year to annual trend factor.</p> required <code>base_year</code> <code>int</code> <p>The year to which all exposures will be trended.</p> required <p>Returns:</p> Name Type Description <code>Exposures</code> <code>Exposures</code> <p>A new Exposures object with trended values.</p> Source code in <code>src\\pyre\\Models\\trending.py</code> <pre><code>def trend_exposures(exposures: Exposures, trend_factors: Dict[int, float], base_year: int) -&gt; Exposures:\n    \"\"\"\n    Apply trend factors to a collection of exposures.\n\n    Args:\n        exposures (Exposures): The original Exposures object.\n        trend_factors (Dict[int, float]): Mapping of year to annual trend factor.\n        base_year (int): The year to which all exposures will be trended.\n\n    Returns:\n        Exposures: A new Exposures object with trended values.\n    \"\"\"\n    trending = Trending(exposure_trend_factors=trend_factors, claim_trend_factors=trend_factors, base_year=base_year)\n    return trending.trend_exposures(exposures)\n</code></pre>"},{"location":"rate_monitoring/","title":"Rate Monitoring Module","text":"<p>The Rate Monitoring module provides tools for tracking and analyzing rate changes and rate adequacy over time. It includes methods for calculating rate change indices and assessing rate adequacy.</p>"},{"location":"rate_monitoring/#core-components","title":"Core Components","text":""},{"location":"rate_monitoring/#rate-change","title":"Rate Change","text":"<p>The rate_change module provides tools for tracking and analyzing rate changes:</p> <ul> <li>Functions for calculating rate change indices</li> <li>Methods for analyzing the impact of rate changes on a portfolio</li> <li>Tools for visualizing rate change trends</li> </ul>"},{"location":"rate_monitoring/#rate-adequacy","title":"Rate Adequacy","text":"<p>The rate_adequacy module provides tools for assessing the adequacy of rates:</p> <ul> <li>Methods for comparing actual vs. expected loss ratios</li> <li>Tools for analyzing rate adequacy by segment</li> <li>Functions for projecting future rate adequacy</li> </ul>"},{"location":"rate_monitoring/#examples","title":"Examples","text":""},{"location":"rate_monitoring/#tracking-rate-changes","title":"Tracking Rate Changes","text":"<pre><code>from pyre.rate_monitoring.rate_change import calculate_rate_change_index\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom datetime import date\n\n# Create sample data\ndata = {\n    'policy_id': ['P001', 'P002', 'P003', 'P004', 'P005'],\n    'effective_date': [date(2022, 1, 1), date(2022, 3, 15), date(2022, 6, 1), \n                       date(2022, 9, 10), date(2022, 11, 20)],\n    'expiration_date': [date(2023, 1, 1), date(2023, 3, 15), date(2023, 6, 1), \n                        date(2023, 9, 10), date(2023, 11, 20)],\n    'premium': [10000, 15000, 8000, 12000, 9000],\n    'rate_change_pct': [0.05, 0.03, 0.07, 0.04, 0.06]  # Rate changes at renewal\n}\n\ndf = pd.DataFrame(data)\n\n# Calculate rate change index\nbase_date = date(2022, 1, 1)\nevaluation_dates = [date(2022, 3, 31), date(2022, 6, 30), \n                   date(2022, 9, 30), date(2022, 12, 31)]\n\nindices = []\nfor eval_date in evaluation_dates:\n    index = calculate_rate_change_index(df, base_date, eval_date)\n    indices.append(index)\n    print(f\"Rate change index as of {eval_date}: {index:.4f}\")\n\n# Plot rate change index over time\nplt.figure(figsize=(10, 6))\nplt.plot([d.strftime('%Y-%m-%d') for d in evaluation_dates], indices, marker='o')\nplt.title('Rate Change Index Over Time')\nplt.xlabel('Evaluation Date')\nplt.ylabel('Rate Change Index')\nplt.grid(True)\nplt.xticks(rotation=45)\nplt.tight_layout()\nplt.show()\n\n# Calculate cumulative rate change\ncumulative_change = (indices[-1] - 1.0) * 100\nprint(f\"Cumulative rate change from {base_date} to {evaluation_dates[-1]}: {cumulative_change:.2f}%\")\n\n# Calculate annualized rate change\ndays_elapsed = (evaluation_dates[-1] - base_date).days\nyears_elapsed = days_elapsed / 365.25\nannualized_change = ((indices[-1]) ** (1/years_elapsed) - 1) * 100\nprint(f\"Annualized rate change: {annualized_change:.2f}%\")\n</code></pre>"},{"location":"rate_monitoring/#analyzing-rate-adequacy","title":"Analyzing Rate Adequacy","text":"<pre><code>from pyre.rate_monitoring.rate_adequacy import calculate_rate_adequacy\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Create sample data\nnp.random.seed(42)\nn_policies = 100\n\ndata = {\n    'policy_id': [f'P{i:03d}' for i in range(1, n_policies + 1)],\n    'line_of_business': np.random.choice(['Property', 'Casualty', 'Marine'], n_policies),\n    'premium': np.random.uniform(5000, 50000, n_policies),\n    'incurred_losses': np.random.uniform(2000, 40000, n_policies),\n    'expected_loss_ratio': np.random.uniform(0.5, 0.7, n_policies)\n}\n\ndf = pd.DataFrame(data)\n\n# Calculate rate adequacy\ndf['actual_loss_ratio'] = df['incurred_losses'] / df['premium']\ndf['rate_adequacy'] = calculate_rate_adequacy(df['actual_loss_ratio'], df['expected_loss_ratio'])\n\n# Print summary statistics\nprint(\"Rate Adequacy Summary:\")\nprint(f\"Average Rate Adequacy: {df['rate_adequacy'].mean():.2%}\")\nprint(f\"Median Rate Adequacy: {df['rate_adequacy'].median():.2%}\")\nprint(f\"Min Rate Adequacy: {df['rate_adequacy'].min():.2%}\")\nprint(f\"Max Rate Adequacy: {df['rate_adequacy'].max():.2%}\")\n\n# Analyze rate adequacy by line of business\nlob_summary = df.groupby('line_of_business').agg({\n    'premium': 'sum',\n    'incurred_losses': 'sum',\n    'rate_adequacy': 'mean'\n}).reset_index()\n\nlob_summary['actual_loss_ratio'] = lob_summary['incurred_losses'] / lob_summary['premium']\n\nprint(\"\\nRate Adequacy by Line of Business:\")\nfor _, row in lob_summary.iterrows():\n    print(f\"{row['line_of_business']}:\")\n    print(f\"  Premium: ${row['premium']:.2f}\")\n    print(f\"  Incurred Losses: ${row['incurred_losses']:.2f}\")\n    print(f\"  Actual Loss Ratio: {row['actual_loss_ratio']:.2%}\")\n    print(f\"  Average Rate Adequacy: {row['rate_adequacy']:.2%}\")\n\n# Visualize rate adequacy distribution\nplt.figure(figsize=(12, 8))\n\n# Histogram of rate adequacy\nplt.subplot(2, 2, 1)\nplt.hist(df['rate_adequacy'], bins=20, alpha=0.7)\nplt.axvline(0, color='r', linestyle='--')\nplt.title('Distribution of Rate Adequacy')\nplt.xlabel('Rate Adequacy')\nplt.ylabel('Frequency')\n\n# Rate adequacy by line of business\nplt.subplot(2, 2, 2)\nbars = plt.bar(lob_summary['line_of_business'], lob_summary['rate_adequacy'])\nfor i, bar in enumerate(bars):\n    if lob_summary['rate_adequacy'].iloc[i] &lt; 0:\n        bar.set_color('red')\n    else:\n        bar.set_color('green')\nplt.axhline(0, color='black', linestyle='-')\nplt.title('Average Rate Adequacy by Line of Business')\nplt.ylabel('Rate Adequacy')\n\n# Scatter plot of premium vs. rate adequacy\nplt.subplot(2, 2, 3)\nfor lob in df['line_of_business'].unique():\n    subset = df[df['line_of_business'] == lob]\n    plt.scatter(subset['premium'], subset['rate_adequacy'], alpha=0.7, label=lob)\nplt.axhline(0, color='r', linestyle='--')\nplt.title('Premium vs. Rate Adequacy')\nplt.xlabel('Premium')\nplt.ylabel('Rate Adequacy')\nplt.legend()\n\n# Actual vs. Expected Loss Ratio\nplt.subplot(2, 2, 4)\nplt.scatter(df['expected_loss_ratio'], df['actual_loss_ratio'], alpha=0.5)\nplt.plot([0.4, 0.8], [0.4, 0.8], 'r--')  # Diagonal line\nplt.title('Actual vs. Expected Loss Ratio')\nplt.xlabel('Expected Loss Ratio')\nplt.ylabel('Actual Loss Ratio')\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"rate_monitoring/#api-reference","title":"API Reference","text":"<p>Rate Change Metrics Calculation Module</p> <p>Bodoff, N. (2009). \"Measuring Rate Change: Methods and Implications.\" https://www.casact.org/sites/default/files/database/forum_09wforum_bodoff.pdf</p> <p>Llloyd's PMDR requirements and calculations</p> <p>https://assets.lloyds.com/media/04e08389-5b68-42a7-aa66-167df72c0721/PMDR-Instructions-2024-V1.0.pdf https://assets.lloyds.com/assets/pdf-performance-management-pmdr-renewal-scenario-examples/1/pdf-performance-management-PMDR-Renewal-Scenario-Examples.pdf</p> <p>Rate Adequacy Calculation Functions</p> <p>Implements rate adequacy calculations as described in: Bodoff, N. (2009). \"Measuring Rate Change: Methods and Implications.\" https://www.casact.org/sites/default/files/database/forum_09wforum_bodoff.pdf</p>"},{"location":"rate_monitoring/#pyre.rate_monitoring.rate_change.rate_change_adjusted","title":"<code>rate_change_adjusted(expiring_premium, renewed_premium, adjusted_expiring_premium=None)</code>","text":"<p>Calculate rate change, optionally adjusting expiring premium for exposure/terms.</p> <p>Parameters:</p> Name Type Description Default <code>expiring_premium</code> <code>float</code> <p>Premium charged last year.</p> required <code>renewed_premium</code> <code>float</code> <p>Premium charged this year.</p> required <code>adjusted_expiring_premium</code> <code>Optional[float]</code> <p>Expiring premium adjusted for exposure/terms.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Rate change as a decimal.</p> Source code in <code>src\\pyre\\rate_monitoring\\rate_change.py</code> <pre><code>def rate_change_adjusted(\n    expiring_premium: float,\n    renewed_premium: float,\n    adjusted_expiring_premium: Optional[float] = None\n) -&gt; float:\n    \"\"\"\n    Calculate rate change, optionally adjusting expiring premium for exposure/terms.\n\n    Args:\n        expiring_premium (float): Premium charged last year.\n        renewed_premium (float): Premium charged this year.\n        adjusted_expiring_premium (Optional[float]): Expiring premium adjusted for exposure/terms.\n\n    Returns:\n        float: Rate change as a decimal.\n    \"\"\"\n    base = adjusted_expiring_premium if adjusted_expiring_premium is not None else expiring_premium\n    if base == 0:\n        raise ValueError(\"Expiring or adjusted expiring premium cannot be zero.\")\n    return (renewed_premium / base) - 1\n</code></pre>"},{"location":"rate_monitoring/#pyre.rate_monitoring.rate_change.rate_change_simple","title":"<code>rate_change_simple(expiring_premium, renewed_premium)</code>","text":"<p>Calculate simple rate change (no adjustment for exposure or terms).</p> <p>Parameters:</p> Name Type Description Default <code>expiring_premium</code> <code>float</code> <p>Premium charged last year.</p> required <code>renewed_premium</code> <code>float</code> <p>Premium charged this year.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Rate change as a decimal (e.g., 0.10 for 10%).</p> Source code in <code>src\\pyre\\rate_monitoring\\rate_change.py</code> <pre><code>def rate_change_simple(expiring_premium: float, renewed_premium: float) -&gt; float:\n    \"\"\"\n    Calculate simple rate change (no adjustment for exposure or terms).\n\n    Args:\n        expiring_premium (float): Premium charged last year.\n        renewed_premium (float): Premium charged this year.\n\n    Returns:\n        float: Rate change as a decimal (e.g., 0.10 for 10%).\n    \"\"\"\n    if expiring_premium == 0:\n        raise ValueError(\"Expiring premium cannot be zero.\")\n    return (renewed_premium / expiring_premium) - 1\n</code></pre>"},{"location":"rate_monitoring/#pyre.rate_monitoring.rate_adequacy.rate_adequacy","title":"<code>rate_adequacy(premium, indicated_premium)</code>","text":"<p>Calculates rate adequacy as the ratio of actual premium to indicated premium.</p> <p>Parameters:</p> Name Type Description Default <code>premium</code> <code>float</code> <p>Actual charged premium.</p> required <code>indicated_premium</code> <code>float</code> <p>Indicated (actuarially adequate) premium.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Rate adequacy (e.g., 1.05 means 5% adequate, 0.95 means 5% inadequate).</p> Source code in <code>src\\pyre\\rate_monitoring\\rate_adequacy.py</code> <pre><code>def rate_adequacy(premium: float, indicated_premium: float) -&gt; float:\n    \"\"\"\n    Calculates rate adequacy as the ratio of actual premium to indicated premium.\n\n    Args:\n        premium (float): Actual charged premium.\n        indicated_premium (float): Indicated (actuarially adequate) premium.\n\n    Returns:\n        float: Rate adequacy (e.g., 1.05 means 5% adequate, 0.95 means 5% inadequate).\n    \"\"\"\n    if indicated_premium == 0:\n        raise ValueError(\"Indicated premium cannot be zero.\")\n    return premium / indicated_premium\n</code></pre>"},{"location":"rate_monitoring/#pyre.rate_monitoring.rate_adequacy.rate_adequacy_change","title":"<code>rate_adequacy_change(prior_premium, prior_indicated, current_premium, current_indicated)</code>","text":"<p>Calculates the change in rate adequacy between two periods.</p> <p>Parameters:</p> Name Type Description Default <code>prior_premium</code> <code>float</code> <p>Actual premium in prior period.</p> required <code>prior_indicated</code> <code>float</code> <p>Indicated premium in prior period.</p> required <code>current_premium</code> <code>float</code> <p>Actual premium in current period.</p> required <code>current_indicated</code> <code>float</code> <p>Indicated premium in current period.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Change in rate adequacy (e.g., 0.05 means 5% improvement).</p> Source code in <code>src\\pyre\\rate_monitoring\\rate_adequacy.py</code> <pre><code>def rate_adequacy_change(\n    prior_premium: float,\n    prior_indicated: float,\n    current_premium: float,\n    current_indicated: float\n) -&gt; float:\n    \"\"\"\n    Calculates the change in rate adequacy between two periods.\n\n    Args:\n        prior_premium (float): Actual premium in prior period.\n        prior_indicated (float): Indicated premium in prior period.\n        current_premium (float): Actual premium in current period.\n        current_indicated (float): Indicated premium in current period.\n\n    Returns:\n        float: Change in rate adequacy (e.g., 0.05 means 5% improvement).\n    \"\"\"\n    prior_adequacy = rate_adequacy(prior_premium, prior_indicated)\n    current_adequacy = rate_adequacy(current_premium, current_indicated)\n    return current_adequacy - prior_adequacy\n</code></pre>"},{"location":"treaty/","title":"Treaty Module","text":"<p>The Treaty module provides tools for modeling reinsurance contracts and layers. It includes classes for representing different types of reinsurance contracts, their metadata, and methods for calculating recoveries.</p>"},{"location":"treaty/#core-classes","title":"Core Classes","text":""},{"location":"treaty/#treaty-data-structure","title":"Treaty Data Structure","text":"<p>The module provides a hierarchical structure for representing reinsurance contracts:</p> <ul> <li><code>ContractType</code>: An enumeration defining different types of reinsurance contracts (Quota Share, Excess of Loss, etc.)</li> <li><code>ClaimTriggerBasis</code>: An enumeration defining different claim trigger bases</li> <li><code>IndexationClauseType</code>: An enumeration defining different types of indexation clauses</li> <li><code>RILayer</code>: Represents a reinsurance layer with properties like attachment points, limits, etc.</li> <li><code>RIContractMetadata</code>: Contains metadata about reinsurance contracts</li> <li><code>RIContract</code>: Combines metadata and layers to represent a complete reinsurance contract</li> </ul>"},{"location":"treaty/#examples","title":"Examples","text":""},{"location":"treaty/#creating-and-working-with-reinsurance-contracts","title":"Creating and Working with Reinsurance Contracts","text":"<pre><code>from pyre.treaty.contracts import RIContract, RIContractMetadata, RILayer, ClaimTriggerBasis, IndexationClauseType\nfrom pyre.treaty.contract_types import ContractType\nfrom datetime import date\n\n# Create contract metadata\nmetadata = RIContractMetadata(\n    contract_id=\"XL001\",\n    contract_description=\"Property Cat XL\",\n    cedent_name=\"ABC Insurance\",\n    trigger_basis=ClaimTriggerBasis.LOSSES_OCCURRING,\n    indexation_clause=IndexationClauseType.NONE,\n    indexation_margin=0.0,\n    inception_date=date(2022, 1, 1),\n    expiration_date=date(2022, 12, 31),\n    fx_rates={\"USD\": 1.0, \"EUR\": 1.1, \"GBP\": 1.3}\n)\n\n# Create a reinsurance layer\nlayer = RILayer(\n    layer_id=1,\n    layer_name=\"First Layer\",\n    layer_type=ContractType.EXCESS_OF_LOSS,\n    occurrence_attachment=10000000,\n    occurrence_limit=20000000,\n    aggregate_attachment=0,\n    aggregate_limit=0,  # Unlimited\n    subject_lines_of_business=[\"Property\"],\n    subject_lob_exposure_amounts=[100000000],\n    full_subject_premium=5000000,\n    written_line=1.0,\n    signed_line=0.1,  # 10% share\n    number_of_reinstatements=1,\n    reinstatement_cost={\"1\": 1.0}  # 100% of premium for first reinstatement\n)\n\n# Create a reinsurance contract\ncontract = RIContract(metadata, [layer])\n\n# Access contract properties\nprint(f\"Contract ID: {contract.contract_meta_data.contract_id}\")\nprint(f\"Contract Description: {contract.contract_meta_data.contract_description}\")\nprint(f\"Contract Period: {contract.contract_meta_data.inception_date} to {contract.contract_meta_data.expiration_date}\")\n\n# Access layer properties\nfor layer_id in contract.layer_ids():\n    layer = contract.layers[layer_id - 1]  # Layer IDs are 1-based\n    print(f\"Layer {layer.layer_id}: {layer.layer_name}\")\n    print(f\"  Attachment: {layer.occurrence_attachment}\")\n    print(f\"  Limit: {layer.occurrence_limit}\")\n    print(f\"  Written Line Premium: {layer.written_line_premium()}\")\n    print(f\"  Signed Line Premium: {layer.signed_line_premium()}\")\n\n# Calculate recovery for a loss\nloss_amount = 25000000\nlayer_recovery = layer.loss_to_layer_fn(loss_amount)\nprint(f\"Recovery for loss of {loss_amount}: {layer_recovery}\")\n</code></pre>"},{"location":"treaty/#working-with-multiple-layers","title":"Working with Multiple Layers","text":"<pre><code>from pyre.treaty.contracts import RIContract, RILayer\nfrom pyre.treaty.contract_types import ContractType\n\n# Assuming we have a contract metadata object called 'contract_metadata'\n\n# Create multiple layers for a property cat program\nlayers = [\n    RILayer(\n        layer_id=1,\n        layer_name=\"Layer 1: 10m xs 10m\",\n        layer_type=ContractType.EXCESS_OF_LOSS,\n        occurrence_attachment=10000000,\n        occurrence_limit=10000000,\n        aggregate_attachment=0,\n        aggregate_limit=20000000,  # 2 full limit losses\n        subject_lines_of_business=[\"Property\"],\n        subject_lob_exposure_amounts=[100000000],\n        full_subject_premium=2000000,\n        written_line=1.0,\n        signed_line=0.15,  # 15% share\n        number_of_reinstatements=1,\n        reinstatement_cost={\"1\": 1.0}\n    ),\n    RILayer(\n        layer_id=2,\n        layer_name=\"Layer 2: 30m xs 20m\",\n        layer_type=ContractType.EXCESS_OF_LOSS,\n        occurrence_attachment=20000000,\n        occurrence_limit=30000000,\n        aggregate_attachment=0,\n        aggregate_limit=60000000,  # 2 full limit losses\n        subject_lines_of_business=[\"Property\"],\n        subject_lob_exposure_amounts=[100000000],\n        full_subject_premium=3000000,\n        written_line=1.0,\n        signed_line=0.1,  # 10% share\n        number_of_reinstatements=1,\n        reinstatement_cost={\"1\": 1.0}\n    ),\n    RILayer(\n        layer_id=3,\n        layer_name=\"Layer 3: 50m xs 50m\",\n        layer_type=ContractType.EXCESS_OF_LOSS,\n        occurrence_attachment=50000000,\n        occurrence_limit=50000000,\n        aggregate_attachment=0,\n        aggregate_limit=100000000,  # 2 full limit losses\n        subject_lines_of_business=[\"Property\"],\n        subject_lob_exposure_amounts=[100000000],\n        full_subject_premium=1500000,\n        written_line=1.0,\n        signed_line=0.05,  # 5% share\n        number_of_reinstatements=1,\n        reinstatement_cost={\"1\": 1.0}\n    )\n]\n\n# Create a reinsurance contract with multiple layers\ncontract = RIContract(contract_metadata, layers)\n\n# Calculate total premium\ntotal_premium = sum(layer.signed_line_premium() for layer in contract.layers)\nprint(f\"Total premium for all layers: {total_premium}\")\n\n# Calculate recovery for a large loss across multiple layers\nloss_amount = 75000000\ntotal_recovery = 0\nfor layer in contract.layers:\n    layer_recovery = layer.loss_to_layer_fn(loss_amount)\n    total_recovery += layer_recovery\n    print(f\"Layer {layer.layer_id} recovery: {layer_recovery}\")\n\nprint(f\"Total recovery for loss of {loss_amount}: {total_recovery}\")\n</code></pre>"},{"location":"treaty/#api-reference","title":"API Reference","text":""}]}