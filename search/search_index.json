{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyRE","text":""},{"location":"#overview","title":"Overview","text":"<p><code>pyre</code> goal is to provide pricing tools and utilities for reinsurnace users. </p>"},{"location":"#features","title":"Features","text":"<ul> <li>Pricing Calculations: Core functionality for actuarial pricing models.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>To install the package, clone the repository and install the dependencies:</p> <pre><code>git clone https://github.com/rdj09/pyre.git\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Here\u2019s a quick example of how to use the package:</p> <pre><code># Import the main module\nfrom pyre \n\n# Example usage\n\n</code></pre>"},{"location":"#directory-structure","title":"Directory Structure","text":""},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please follow these steps: 1. Fork the repository. 2. Create a new branch for your feature or bug fix. 3. Submit a pull request with a detailed description of your changes.</p>"},{"location":"#license","title":"License","text":"<p><code>pyre</code> is distributed under the terms of the MIT license.</p>"},{"location":"about/","title":"Boilerplate","text":""},{"location":"about/#reference","title":"Reference","text":"<p>Note</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p>"},{"location":"about/#pyre.claims.claims.Claim","title":"<code>Claim</code>","text":"<p>Represents an insurance claim with associated metadata and development history.</p> <p>This class provides access to the claim's metadata, uncapped and capped development histories, and a string representation for easy inspection. The uncapped and capped development histories are calculated based on the contract deductible and limit specified in the claim's metadata.</p> <p>Attributes:</p> Name Type Description <code>_claims_meta_data</code> <code>ClaimsMetaData</code> <p>Metadata associated with the claim, such as claim ID, deductible, and limit.</p> <code>_claim_development_history</code> <code>ClaimDevelopmentHistory</code> <p>The development history of the claim, including paid and incurred amounts over time.</p> Properties <p>claims_meta_data: Returns the claim's metadata. uncapped_claim_development_history: Returns the claim's development history after applying the deductible, but before applying the contract limit. capped_claim_development_history: Returns the claim's development history after applying both the deductible and the contract limit.</p> <p>Parameters:</p> Name Type Description Default <code>claims_meta_data</code> <code>ClaimsMetaData</code> <p>Metadata for the claim.</p> required <code>claims_development_history</code> <code>ClaimDevelopmentHistory</code> <p>Development history for the claim.</p> required Example <p>claim = Claim(meta_data, dev_history) print(claim.capped_claim_development_history)</p> Source code in <code>src\\pyre\\claims\\claims.py</code> <pre><code>class Claim:\n    \"\"\"Represents an insurance claim with associated metadata and development history.\n\n    This class provides access to the claim's metadata, uncapped and capped development histories,\n    and a string representation for easy inspection. The uncapped and capped development histories\n    are calculated based on the contract deductible and limit specified in the claim's metadata.\n\n    Attributes:\n        _claims_meta_data (ClaimsMetaData): Metadata associated with the claim, such as claim ID, deductible, and limit.\n        _claim_development_history (ClaimDevelopmentHistory): The development history of the claim, including paid and incurred amounts over time.\n\n    Properties:\n        claims_meta_data: Returns the claim's metadata.\n        uncapped_claim_development_history: Returns the claim's development history after applying the deductible, but before applying the contract limit.\n        capped_claim_development_history: Returns the claim's development history after applying both the deductible and the contract limit.\n\n    Args:\n        claims_meta_data (ClaimsMetaData): Metadata for the claim.\n        claims_development_history (ClaimDevelopmentHistory): Development history for the claim.\n\n    Example:\n        &gt;&gt;&gt; claim = Claim(meta_data, dev_history)\n        &gt;&gt;&gt; print(claim.capped_claim_development_history)\n    \"\"\"\n    def __init__(self, claims_meta_data: ClaimsMetaData, claims_development_history: ClaimDevelopmentHistory) -&gt; None:\n        self._claims_meta_data = claims_meta_data\n        self._claim_development_history = claims_development_history\n\n    @property\n    def claims_meta_data(self):\n        return self._claims_meta_data\n\n    @property\n    def uncapped_claim_development_history(self) -&gt; ClaimDevelopmentHistory:\n        if self._claims_meta_data.claim_in_xs_of_deductible:\n            uncapped_paid = self._claim_development_history.cumulative_dev_paid\n            uncapped_incurred = self._claim_development_history.cumulative_dev_incurred\n        else:\n            uncapped_paid = [max(paid - self._claims_meta_data.contract_deductible, 0.0) for paid in self._claim_development_history.cumulative_dev_paid]\n            uncapped_incurred = [max(incurred - self._claims_meta_data.contract_deductible, 0.0) for incurred in self._claim_development_history.cumulative_dev_incurred]\n        self._uncapped_claim_development_history = ClaimDevelopmentHistory(self._claim_development_history.development_months, uncapped_paid, uncapped_incurred)\n        return self._uncapped_claim_development_history\n\n    @property\n    def capped_claim_development_history(self) -&gt; ClaimDevelopmentHistory:\n        capped_paid = [min(paid, self._claims_meta_data.contract_limit) for paid in self.uncapped_claim_development_history.cumulative_dev_paid]\n        capped_incurred = [min(incurred, self._claims_meta_data.contract_limit) for incurred in self.uncapped_claim_development_history.cumulative_dev_incurred]\n        self._capped_claim_development_history = ClaimDevelopmentHistory(self._claim_development_history.development_months, capped_paid, capped_incurred)\n        return self._capped_claim_development_history \n\n\n    def __repr__(self) -&gt; str:\n        return (\n            f\"claim_id={self._claims_meta_data.claim_id},modelling_year={self._claims_meta_data.modelling_year},latest_incurred={self._claim_development_history.latest_incurred},latest_capped_incurred={self.capped_claim_development_history.latest_incurred}\"\n        )\n</code></pre>"},{"location":"about/#pyre.claims.claims.ClaimDevelopmentHistory","title":"<code>ClaimDevelopmentHistory</code>  <code>dataclass</code>","text":"<p>Represents the development history of an insurance claim, tracking cumulative and incremental paid and incurred amounts over development months.</p> <p>Attributes:</p> Name Type Description <code>development_months</code> <code>Sequence[int]</code> <p>List of development months corresponding to each data point.</p> <code>cumulative_dev_paid</code> <code>Sequence[float]</code> <p>Cumulative paid amounts at each development month.</p> <code>cumulative_dev_incurred</code> <code>Sequence[float]</code> <p>Cumulative incurred amounts at each development month.</p> Properties <p>cumulative_reserved_amount (list[float]): List of reserved amounts (incurred minus paid) at each development month. latest_paid (float): Most recent cumulative paid amount, or 0.0 if no data. latest_incurred (float): Most recent cumulative incurred amount, or 0.0 if no data. latest_reserved_amount (float): Most recent reserved amount (incurred minus paid), or 0.0 if no data. latest_development_month (int): Most recent development month, or 0 if no data. incremental_dev_incurred (List[float]): List of incremental incurred amounts at each development month. incremental_dev_paid (List[float]): List of incremental paid amounts at each development month. mean_payment_duration (Optional[float]): Weighted average development month of payments, or None if no payments.</p> <p>Methods:</p> Name Description <code>incremental_dev</code> <p>Sequence[float]) -&gt; List[float]: Converts a sequence of cumulative values into incremental values.</p> Source code in <code>src\\pyre\\claims\\claims.py</code> <pre><code>@dataclass\nclass ClaimDevelopmentHistory:\n    \"\"\"Represents the development history of an insurance claim, tracking cumulative and incremental paid and incurred amounts over development months.\n\n    Attributes:\n        development_months (Sequence[int]): List of development months corresponding to each data point.\n        cumulative_dev_paid (Sequence[float]): Cumulative paid amounts at each development month.\n        cumulative_dev_incurred (Sequence[float]): Cumulative incurred amounts at each development month.\n\n    Properties:\n        cumulative_reserved_amount (list[float]): List of reserved amounts (incurred minus paid) at each development month.\n        latest_paid (float): Most recent cumulative paid amount, or 0.0 if no data.\n        latest_incurred (float): Most recent cumulative incurred amount, or 0.0 if no data.\n        latest_reserved_amount (float): Most recent reserved amount (incurred minus paid), or 0.0 if no data.\n        latest_development_month (int): Most recent development month, or 0 if no data.\n        incremental_dev_incurred (List[float]): List of incremental incurred amounts at each development month.\n        incremental_dev_paid (List[float]): List of incremental paid amounts at each development month.\n        mean_payment_duration (Optional[float]): Weighted average development month of payments, or None if no payments.\n\n    Methods:\n        incremental_dev(cumulative_dev: Sequence[float]) -&gt; List[float]:\n            Converts a sequence of cumulative values into incremental values.\n    \"\"\"\n    development_months: Sequence[int] = field(default_factory=list)\n    cumulative_dev_paid: Sequence[float] = field(default_factory=list)\n    cumulative_dev_incurred: Sequence[float] = field(default_factory=list)\n\n    @property\n    def cumulative_reserved_amount(self) -&gt; list[float]:\n        if len(self.cumulative_dev_incurred) != len(self.cumulative_dev_paid):\n            raise ValueError(\"Both lists must have the same length.\")\n        return [incurred - paid for incurred, paid in zip(self.cumulative_dev_incurred, self.cumulative_dev_paid)]\n\n    @property\n    def latest_paid(self) -&gt; float:\n        return self.cumulative_dev_paid[-1] if self.cumulative_dev_paid else 0.0\n\n    @property\n    def latest_incurred(self) -&gt; float:\n        return self.cumulative_dev_incurred[-1] if self.cumulative_dev_incurred else 0.0\n\n    @property\n    def latest_reserved_amount(self) -&gt; float:\n        return self.cumulative_dev_incurred[-1] - self.cumulative_dev_paid[-1] if self.cumulative_dev_paid else 0.0\n\n    @property\n    def latest_development_month(self) -&gt; int:\n        return self.development_months[-1] if self.development_months else 0\n\n    @staticmethod\n    def incremental_dev(cumulative_dev: Sequence[float]) -&gt; List[float]:\n        incremental_dev = [cumulative_dev[0]]\n        incremental_dev.extend([cumulative_dev[i] - cumulative_dev[i - 1] for i in range(1, len(cumulative_dev))])\n        return incremental_dev\n    @property\n    def incremental_dev_incurred(self) -&gt; List[float]:\n        self.incremental_dev(self.cumulative_dev_incurred)\n        return self.incremental_dev(self.cumulative_dev_incurred)\n\n    @property #\n    def incremental_dev_paid(self) -&gt; List[float]:\n        self.incremental_dev(self.cumulative_dev_paid)\n        return self.incremental_dev(self.cumulative_dev_paid)\n\n    @property\n    def mean_payment_duration(self) -&gt; Optional[float]:\n        if self.latest_paid &gt; 0:\n            time_weighted_payments = sum(month * paid for month, paid in zip(self.development_months, self.incremental_dev_paid))\n            return time_weighted_payments / self.latest_paid\n        return None\n</code></pre>"},{"location":"about/#pyre.claims.claims.ClaimYearType","title":"<code>ClaimYearType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of claim year types used in insurance data analysis.</p> <p>Attributes:</p> Name Type Description <code>ACCIDENT_YEAR</code> <p>Represents the year in which the insured event (accident) occurred.</p> <code>UNDERWRITING_YEAR</code> <p>Represents the year in which the insurance policy was underwritten or issued.</p> <code>REPORTED_YEAR</code> <p>Represents the year in which the claim was reported to the insurer.</p> Source code in <code>src\\pyre\\claims\\claims.py</code> <pre><code>class ClaimYearType(Enum):\n    \"\"\"Enumeration of claim year types used in insurance data analysis.\n\n    Attributes:\n        ACCIDENT_YEAR: Represents the year in which the insured event (accident) occurred.\n        UNDERWRITING_YEAR: Represents the year in which the insurance policy was underwritten or issued.\n        REPORTED_YEAR: Represents the year in which the claim was reported to the insurer.\n    \"\"\"\n    ACCIDENT_YEAR = auto()\n    UNDERWRITING_YEAR = auto()\n    REPORTED_YEAR = auto()\n</code></pre>"},{"location":"about/#pyre.claims.claims.Claims","title":"<code>Claims</code>","text":"<p>A container class for managing a collection of Claim objects.</p> <p>This class provides convenient accessors and methods for working with a list of claims, including retrieving modelling years, development periods, and currencies represented in the claims. It also supports list-like behaviors such as indexing, slicing, appending, and iteration.</p> <p>Attributes:</p> Name Type Description <code>claims</code> <code>list[Claim]</code> <p>The list of Claim objects managed by this container.</p> Properties <p>modelling_years (List): Sorted list of unique modelling years across all claims. development_periods (List): Sorted list of unique development periods (in months) across all claims. currencies (Set): Set of unique currencies represented in the claims.</p> <p>Methods:</p> Name Description <code>append</code> <p>Claim): Appends a Claim object to the collection.</p> <code>__getitem__</code> <p>Supports indexing and slicing to access claims.</p> <code>__iter__</code> <p>Returns an iterator over the claims.</p> <code>__len__</code> <p>Returns the number of claims in the collection.</p> Source code in <code>src\\pyre\\claims\\claims.py</code> <pre><code>class Claims:\n    \"\"\"A container class for managing a collection of Claim objects.\n\n    This class provides convenient accessors and methods for working with a list of claims,\n    including retrieving modelling years, development periods, and currencies represented in the claims.\n    It also supports list-like behaviors such as indexing, slicing, appending, and iteration.\n\n    Attributes:\n        claims (list[Claim]): The list of Claim objects managed by this container.\n\n    Properties:\n        modelling_years (List): Sorted list of unique modelling years across all claims.\n        development_periods (List): Sorted list of unique development periods (in months) across all claims.\n        currencies (Set): Set of unique currencies represented in the claims.\n\n    Methods:\n        append(claim: Claim): Appends a Claim object to the collection.\n        __getitem__(key): Supports indexing and slicing to access claims.\n        __iter__(): Returns an iterator over the claims.\n        __len__(): Returns the number of claims in the collection.\n    \"\"\"\n    def __init__(self, claims: list[Claim]) -&gt; None:\n        self._claims = claims\n\n    @property\n    def claims(self):\n        return self._claims\n\n    @claims.setter\n    def claims(self, list_of_claim_classes:list[Claim]):\n        self._claims = list_of_claim_classes\n\n    @property\n    def modelling_years(self) -&gt; List:\n        \"\"\"\n        Returns a list of modelling years for all claims.\n        \"\"\"\n        years = {claim.claims_meta_data.modelling_year for claim in self.claims}\n        return sorted(years)\n\n    @property\n    def development_periods(self) -&gt; List:\n        \"\"\"\n        Returns a list of modelling years for all claims.\n        \"\"\"\n        dev_periods = {claim.capped_claim_development_history.development_months for claim in self.claims}\n        return sorted(dev_periods)\n\n    @property\n    def currencies(self) -&gt; Set:\n        \"\"\"\n        Returns a list of currencies for all claims.\n        \"\"\"\n        return {claim.claims_meta_data.currency for claim in self.claims}\n\n    def append(self, claim: Claim):\n        self._claims.append(claim)\n\n    def __getitem__(self, key):\n        if isinstance(key,slice):\n            cls = type(self)\n            return cls(self._claims[key])\n        index = operator.index(key)\n        return self._claims[index]\n\n    def __iter__(self):\n        return iter(self._claims)\n\n    def __len__(self):\n        return len(self._claims)\n</code></pre>"},{"location":"about/#pyre.claims.claims.Claims.currencies","title":"<code>currencies</code>  <code>property</code>","text":"<p>Returns a list of currencies for all claims.</p>"},{"location":"about/#pyre.claims.claims.Claims.development_periods","title":"<code>development_periods</code>  <code>property</code>","text":"<p>Returns a list of modelling years for all claims.</p>"},{"location":"about/#pyre.claims.claims.Claims.modelling_years","title":"<code>modelling_years</code>  <code>property</code>","text":"<p>Returns a list of modelling years for all claims.</p>"},{"location":"about/#pyre.claims.claims.ClaimsMetaData","title":"<code>ClaimsMetaData</code>  <code>dataclass</code>","text":"<p>Metadata for an insurance claim, including key dates, financial limits, and classification details.</p> <p>Attributes:</p> Name Type Description <code>claim_id</code> <code>str</code> <p>Unique identifier for the claim.</p> <code>currency</code> <code>str</code> <p>Currency code for the claim amounts.</p> <code>contract_limit</code> <code>float</code> <p>Maximum limit of the insurance contract. Defaults to 0.0.</p> <code>contract_deductible</code> <code>float</code> <p>Deductible amount for the contract. Defaults to 0.0.</p> <code>claim_in_xs_of_deductible</code> <code>bool</code> <p>Indicates if the claim is in excess of the deductible. Defaults to False.</p> <code>claim_year_basis</code> <code>ClaimYearType</code> <p>Basis for determining the claim year (e.g., accident, underwriting, reported). Defaults to ClaimYearType.ACCIDENT_YEAR.</p> <code>loss_date</code> <code>date</code> <p>Date of loss occurrence. Defaults to 1900-01-01.</p> <code>policy_inception_date</code> <code>date</code> <p>Policy inception date. Defaults to 1900-01-01.</p> <code>report_date</code> <code>date</code> <p>Date the claim was reported. Defaults to 1900-01-01.</p> <code>line_of_business</code> <code>Optional[str]</code> <p>Line of business associated with the claim. Defaults to None.</p> <code>status</code> <code>Optional[str]</code> <p>Status of the claim (e.g., \"Open\", \"Closed\"). Defaults to \"Open\".</p> Properties <p>modelling_year (ClaimsException | int): Returns the modelling year based on the claim_year_basis, or raises ClaimsException if required date is missing.</p> Source code in <code>src\\pyre\\claims\\claims.py</code> <pre><code>@dataclass\nclass ClaimsMetaData:\n    \"\"\"Metadata for an insurance claim, including key dates, financial limits, and classification details.\n\n    Attributes:\n        claim_id (str): Unique identifier for the claim.\n        currency (str): Currency code for the claim amounts.\n        contract_limit (float): Maximum limit of the insurance contract. Defaults to 0.0.\n        contract_deductible (float): Deductible amount for the contract. Defaults to 0.0.\n        claim_in_xs_of_deductible (bool): Indicates if the claim is in excess of the deductible. Defaults to False.\n        claim_year_basis (ClaimYearType): Basis for determining the claim year (e.g., accident, underwriting, reported). Defaults to ClaimYearType.ACCIDENT_YEAR.\n        loss_date (date): Date of loss occurrence. Defaults to 1900-01-01.\n        policy_inception_date (date): Policy inception date. Defaults to 1900-01-01.\n        report_date (date): Date the claim was reported. Defaults to 1900-01-01.\n        line_of_business (Optional[str]): Line of business associated with the claim. Defaults to None.\n        status (Optional[str]): Status of the claim (e.g., \"Open\", \"Closed\"). Defaults to \"Open\".\n\n    Properties:\n        modelling_year (ClaimsException | int): Returns the modelling year based on the claim_year_basis, or raises ClaimsException if required date is missing.\n    \"\"\"\n    claim_id: str\n    currency: str\n    contract_limit: float = 0.0\n    contract_deductible: float = 0.0\n    claim_in_xs_of_deductible: bool = False\n    claim_year_basis: ClaimYearType = ClaimYearType.ACCIDENT_YEAR\n    loss_date: date = date(day=1,month=1,year= 1900)\n    policy_inception_date: date = date(day=1,month=1,year= 1900)\n    report_date: date = date(day=1,month=1,year= 1900)\n    line_of_business: Optional[str] = None\n    status: Optional[str] = \"Open\"\n\n    @property\n    def modelling_year (self) -&gt; ClaimsException | int:\n        _modeling_basis_years={\n            ClaimYearType.ACCIDENT_YEAR: self.loss_date.year,\n            ClaimYearType.UNDERWRITING_YEAR: self.policy_inception_date.year,\n            ClaimYearType.REPORTED_YEAR: self.report_date.year\n        }\n        if self.claim_year_basis in _modeling_basis_years:\n            return _modeling_basis_years[self.claim_year_basis]\n        else: \n            return ClaimsException(\n                claim_id=self.claim_id, \n                message=\"Required date missing from data\"\n                )\n</code></pre>"},{"location":"about/#armis-nymphae","title":"Armis nymphae","text":"<p>Lorem markdownum canis, qui te Quirine Labros is inops partes et indomito tereti locutum, detur! Unum est coirent saucia suos vento! Inque pontusque sucus trepidantum quae, attonitamque quae tantum et sanguine temptasse Caenis ornant, pressus. Manus inspicitur quod!</p> <p>Et audeat mirabere cupiasque insidias tegit: pepulere videt. Summo tepido exhortantur lupo.</p> <ol> <li>Pontus frustra quidem</li> <li>Illi clarus tamen nescis agitavit</li> <li>Inachis crepitantibus draconi deficiunt poteram</li> <li>Usque relictum urbem hac prudentia</li> <li>Si quae quondam altera</li> </ol>"},{"location":"about/#meis-est-labefactaque-relicta-mihi-quamvis-est","title":"Meis est labefactaque relicta mihi quamvis est","text":"<p>Matre sub habenas everberat Ulixem mitescere iam genus: Echion obprobrium quod, busta contigerant fortius. Belli velavit eruerit equorum tecta sitim pariterque virgo, pavefactaque viderat qua habet, transferre intus, Iri suos ferrumque. Refers corripit moris ne tamen anni unda aura adversos vires. Nec novae volucres premeret et delet trepidos annum. Flore cum ut gravitate duarum memorant sparsus si multum iubasque stratosque nervis annosa?</p> <p>Ipse fatali, quatiens, o proditione mutum, clausit annum cum postquam suam dubium. Perque tu nullos moveo; exacta spumantis quemquam, explevit, tamen caelo sola splendida.</p>"}]}